<html lang="en">
<head>
<title>Records - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Reading-Files.html#Reading-Files" title="Reading Files">
<link rel="next" href="Fields.html#Fields" title="Fields">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Records"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Fields.html#Fields">Fields</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Reading-Files.html#Reading-Files">Reading Files</a>
<hr>
</div>

<h3 class="section">3.1 How Input Is Split into Records</h3>

<!-- STARTOFRANGE inspl -->
<p><a name="index-input_002c-splitting-into-records-348"></a><!-- STARTOFRANGE recspl -->
<a name="index-records_002c-splitting-input-into-349"></a><a name="index-g_t_0040code_007bNR_007d-variable-350"></a><a name="index-g_t_0040code_007bFNR_007d-variable-351"></a>The <samp><span class="command">awk</span></samp> utility divides the input for your <samp><span class="command">awk</span></samp>
program into records and fields. 
<samp><span class="command">awk</span></samp> keeps track of the number of records that have
been read
so far
from the current input file.  This value is stored in a
built-in variable called <code>FNR</code>.  It is reset to zero when a new
file is started.  Another built-in variable, <code>NR</code>, is the total
number of input records read so far from all data files.  It starts at zero,
but is never automatically reset to zero.

   <p><a name="index-separators_002c-for-records-352"></a><a name="index-record-separators-353"></a>Records are separated by a character called the <dfn>record separator</dfn>. 
By default, the record separator is the newline character. 
This is why records are, by default, single lines. 
A different character can be used for the record separator by
assigning the character to the built-in variable <code>RS</code>.

   <p><a name="index-newlines_002c-as-record-separators-354"></a><a name="index-g_t_0040code_007bRS_007d-variable-355"></a>Like any other variable,
the value of <code>RS</code> can be changed in the <samp><span class="command">awk</span></samp> program
with the assignment operator, &lsquo;<samp><span class="samp">=</span></samp>&rsquo;
(see <a href="Assignment-Ops.html#Assignment-Ops">Assignment Ops</a>). 
The new record-separator character should be enclosed in quotation marks,
which indicate a string constant.  Often the right time to do this is
at the beginning of execution, before any input is processed,
so that the very first record is read with the proper separator. 
To do this, use the special <code>BEGIN</code> pattern
(see <a href="BEGIN_002fEND.html#BEGIN_002fEND">BEGIN/END</a>). 
For example:

   <p><a name="index-g_t_0040code_007bBEGIN_007d-pattern-356"></a>
<pre class="example">     awk 'BEGIN { RS = "/" }
          { print $0 }' BBS-list
</pre>
   <p class="noindent">changes the value of <code>RS</code> to <code>"/"</code>, before reading any input. 
This is a string whose first character is a slash; as a result, records
are separated by slashes.  Then the input file is read, and the second
rule in the <samp><span class="command">awk</span></samp> program (the action with no pattern) prints each
record.  Because each <code>print</code> statement adds a newline at the end of
its output, this <samp><span class="command">awk</span></samp> program copies the input
with each slash changed to a newline.  Here are the results of running
the program on <samp><span class="file">BBS-list</span></samp>:

<pre class="example">     $ awk 'BEGIN { RS = "/" }
     &gt;      { print $0 }' BBS-list
     -| aardvark     555-5553     1200
     -| 300          B
     -| alpo-net     555-3412     2400
     -| 1200
     -| 300     A
     -| barfly       555-7685     1200
     -| 300          A
     -| bites        555-1675     2400
     -| 1200
     -| 300     A
     -| camelot      555-0542     300               C
     -| core         555-2912     1200
     -| 300          C
     -| fooey        555-1234     2400
     -| 1200
     -| 300     B
     -| foot         555-6699     1200
     -| 300          B
     -| macfoo       555-6480     1200
     -| 300          A
     -| sdace        555-3430     2400
     -| 1200
     -| 300     A
     -| sabafoo      555-2127     1200
     -| 300          C
     -|
</pre>
   <p class="noindent">Note that the entry for the &lsquo;<samp><span class="samp">camelot</span></samp>&rsquo; BBS is not split. 
In the original data file
(see <a href="Sample-Data-Files.html#Sample-Data-Files">Sample Data Files</a>),
the line looks like this:

<pre class="example">     camelot      555-0542     300               C
</pre>
   <p class="noindent">It has one baud rate only, so there are no slashes in the record,
unlike the others which have two or more baud rates. 
In fact, this record is treated as part of the record
for the &lsquo;<samp><span class="samp">core</span></samp>&rsquo; BBS; the newline separating them in the output
is the original newline in the data file, not the one added by
<samp><span class="command">awk</span></samp> when it printed the record!

   <p><a name="index-record-separators_002c-changing-357"></a><a name="index-separators_002c-for-records-358"></a>Another way to change the record separator is on the command line,
using the variable-assignment feature
(see <a href="Other-Arguments.html#Other-Arguments">Other Arguments</a>):

<pre class="example">     awk '{ print $0 }' RS="/" BBS-list
</pre>
   <p class="noindent">This sets <code>RS</code> to &lsquo;<samp><span class="samp">/</span></samp>&rsquo; before processing <samp><span class="file">BBS-list</span></samp>.

   <p>Using an unusual character such as &lsquo;<samp><span class="samp">/</span></samp>&rsquo; for the record separator
produces correct behavior in the vast majority of cases.  However,
the following (extreme) pipeline prints a surprising &lsquo;<samp><span class="samp">1</span></samp>&rsquo;:

<pre class="example">     $ echo | awk 'BEGIN { RS = "a" } ; { print NF }'
     -| 1
</pre>
   <p>There is one field, consisting of a newline.  The value of the built-in
variable <code>NF</code> is the number of fields in the current record.

   <p><a name="index-dark-corner_002c-input-files-359"></a>Reaching the end of an input file terminates the current input record,
even if the last character in the file is not the character in <code>RS</code>. 
(d.c.)

   <p><a name="index-null-strings-360"></a><a name="index-strings_002c-empty_002c-See-null-strings-361"></a>The empty string <code>""</code> (a string without any characters)
has a special meaning
as the value of <code>RS</code>. It means that records are separated
by one or more blank lines and nothing else. 
See <a href="Multiple-Line.html#Multiple-Line">Multiple Line</a>, for more details.

   <p>If you change the value of <code>RS</code> in the middle of an <samp><span class="command">awk</span></samp> run,
the new value is used to delimit subsequent records, but the record
currently being processed, as well as records already processed, are not
affected.

   <p><a name="index-g_t_0040code_007bRT_007d-variable-362"></a><a name="index-records_002c-terminating-363"></a><a name="index-terminating-records-364"></a><a name="index-differences-in-_0040command_007bawk_007d-and-_0040command_007bgawk_007d_002c-record-separators-365"></a><a name="index-regular-expressions_002c-as-record-separators-366"></a><a name="index-record-separators_002c-regular-expressions-as-367"></a><a name="index-separators_002c-for-records_002c-regular-expressions-as-368"></a>After the end of the record has been determined, <samp><span class="command">gawk</span></samp>
sets the variable <code>RT</code> to the text in the input that matched
<code>RS</code>. 
When using <samp><span class="command">gawk</span></samp>,
the value of <code>RS</code> is not limited to a one-character
string.  It can be any regular expression
(see <a href="Regexp.html#Regexp">Regexp</a>). 
In general, each record
ends at the next string that matches the regular expression; the next
record starts at the end of the matching string.  This general rule is
actually at work in the usual case, where <code>RS</code> contains just a
newline: a record ends at the beginning of the next matching string (the
next newline in the input), and the following record starts just after
the end of this string (at the first character of the following line). 
The newline, because it matches <code>RS</code>, is not part of either record.

   <p>When <code>RS</code> is a single character, <code>RT</code>
contains the same single character. However, when <code>RS</code> is a
regular expression, <code>RT</code> contains
the actual input text that matched the regular expression.

   <p>The following example illustrates both of these features. 
It sets <code>RS</code> equal to a regular expression that
matches either a newline or a series of one or more uppercase letters
with optional leading and/or trailing whitespace:

<pre class="example">     $ echo record 1 AAAA record 2 BBBB record 3 |
     &gt; gawk 'BEGIN { RS = "\n|( *[[:upper:]]+ *)" }
     &gt;             { print "Record =", $0, "and RT =", RT }'
     -| Record = record 1 and RT =  AAAA
     -| Record = record 2 and RT =  BBBB
     -| Record = record 3 and RT =
     -|
</pre>
   <p class="noindent">The final line of output has an extra blank line. This is because the
value of <code>RT</code> is a newline, and the <code>print</code> statement
supplies its own terminating newline. 
See <a href="Simple-Sed.html#Simple-Sed">Simple Sed</a>, for a more useful example
of <code>RS</code> as a regexp and <code>RT</code>.

   <p>If you set <code>RS</code> to a regular expression that allows optional
trailing text, such as &lsquo;<samp><span class="samp">RS = "abc(XYZ)?"</span></samp>&rsquo; it is possible, due
to implementation constraints, that <samp><span class="command">gawk</span></samp> may match the leading
part of the regular expression, but not the trailing part, particularly
if the input text that could match the trailing part is fairly long. 
<samp><span class="command">gawk</span></samp> attempts to avoid this problem, but currently, there's
no guarantee that this will never happen.

   <blockquote>
<b>NOTE:</b> Remember that in <samp><span class="command">awk</span></samp>, the &lsquo;<samp><span class="samp">^</span></samp>&rsquo; and &lsquo;<samp><span class="samp">$</span></samp>&rsquo; anchor
metacharacters match the beginning and end of a <em>string</em>, and not
the beginning and end of a <em>line</em>.  As a result, something like
&lsquo;<samp><span class="samp">RS = "^[[:upper:]]"</span></samp>&rsquo; can only match at the beginning of a file. 
This is because <samp><span class="command">gawk</span></samp> views the input file as one long string
that happens to contain newline characters in it. 
It is thus best to avoid anchor characters in the value of <code>RS</code>. 
</blockquote>

   <p><a name="index-differences-in-_0040command_007bawk_007d-and-_0040command_007bgawk_007d_002c-_0040code_007bRS_007d_002f_0040code_007bRT_007d-variables-369"></a>The use of <code>RS</code> as a regular expression and the <code>RT</code>
variable are <samp><span class="command">gawk</span></samp> extensions; they are not available in
compatibility mode
(see <a href="Options.html#Options">Options</a>). 
In compatibility mode, only the first character of the value of
<code>RS</code> is used to determine the end of the record.

<!-- fakenode - for prepinfo -->
<h4 class="subheading">Advanced Notes: <code>RS = "\0"</code> Is Not Portable</h4>

<p><a name="index-advanced-features_002c-_0040value_007bDF_007ds-as-single-record-370"></a><a name="index-portability_002c-_0040value_007bDF_007ds-as-single-record-371"></a>There are times when you might want to treat an entire data file as a
single record.  The only way to make this happen is to give <code>RS</code>
a value that you know doesn't occur in the input file.  This is hard
to do in a general way, such that a program always works for arbitrary
input files. 
<!-- can you say `understatement' boys and girls? -->

   <p>You might think that for text files, the <span class="sc">nul</span> character, which
consists of a character with all bits equal to zero, is a good
value to use for <code>RS</code> in this case:

<pre class="example">     BEGIN { RS = "\0" }  # whole file becomes one record?
</pre>
   <p><a name="index-differences-in-_0040command_007bawk_007d-and-_0040command_007bgawk_007d_002c-strings_002c-storing-372"></a><samp><span class="command">gawk</span></samp> in fact accepts this, and uses the <span class="sc">nul</span>
character for the record separator. 
However, this usage is <em>not</em> portable
to other <samp><span class="command">awk</span></samp> implementations.

   <p><a name="index-dark-corner_002c-strings_002c-storing-373"></a>All other <samp><span class="command">awk</span></samp> implementations<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a> store strings internally as C-style strings.  C strings use the
<span class="sc">nul</span> character as the string terminator.  In effect, this means that
&lsquo;<samp><span class="samp">RS = "\0"</span></samp>&rsquo; is the same as &lsquo;<samp><span class="samp">RS = ""</span></samp>&rsquo;. 
(d.c.)

   <p><a name="index-records_002c-treating-files-as-374"></a><a name="index-files_002c-as-single-records-375"></a>The best way to treat a whole file as a single record is to
simply read the file in, one record at a time, concatenating each
record onto the end of the previous ones. 
<!-- ENDOFRANGE inspl -->
<!-- ENDOFRANGE recspl -->

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> At least that we know
about.</p>

   <hr></div>

   </body></html>

