<html lang="en">
<head>
<title>Egrep Program - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Clones.html#Clones" title="Clones">
<link rel="prev" href="Cut-Program.html#Cut-Program" title="Cut Program">
<link rel="next" href="Id-Program.html#Id-Program" title="Id Program">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Egrep-Program"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Id-Program.html#Id-Program">Id Program</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Cut-Program.html#Cut-Program">Cut Program</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Clones.html#Clones">Clones</a>
<hr>
</div>

<h4 class="subsection">13.2.2 Searching for Regular Expressions in Files</h4>

<!-- STARTOFRANGE regexps -->
<p><a name="index-regular-expressions_002c-searching-for-1765"></a><!-- STARTOFRANGE sfregexp -->
<a name="index-searching_002c-files-for-regular-expressions-1766"></a><!-- STARTOFRANGE fsregexp -->
<a name="index-files_002c-searching-for-regular-expressions-1767"></a><a name="index-g_t_0040command_007begrep_007d-utility-1768"></a>The <samp><span class="command">egrep</span></samp> utility searches files for patterns.  It uses regular
expressions that are almost identical to those available in <samp><span class="command">awk</span></samp>
(see <a href="Regexp.html#Regexp">Regexp</a>). 
It is used in the following manner:

<pre class="example">     egrep <span class="roman">[</span> <var>options</var> <span class="roman">]</span> '<var>pattern</var>' <var>files</var> ...
</pre>
   <p>The <var>pattern</var> is a regular expression.  In typical usage, the regular
expression is quoted to prevent the shell from expanding any of the
special characters as file name wildcards.  Normally, <samp><span class="command">egrep</span></samp>
prints the lines that matched.  If multiple file names are provided on
the command line, each output line is preceded by the name of the file
and a colon.

   <p>The options to <samp><span class="command">egrep</span></samp> are as follows:

     <dl>
<dt><code>-c</code><dd>Print out a count of the lines that matched the pattern, instead of the
lines themselves.

     <br><dt><code>-s</code><dd>Be silent.  No output is produced and the exit value indicates whether
the pattern was matched.

     <br><dt><code>-v</code><dd>Invert the sense of the test. <samp><span class="command">egrep</span></samp> prints the lines that do
<em>not</em> match the pattern and exits successfully if the pattern is not
matched.

     <br><dt><code>-i</code><dd>Ignore case distinctions in both the pattern and the input data.

     <br><dt><code>-l</code><dd>Only print (list) the names of the files that matched, not the lines that matched.

     <br><dt><code>-e </code><var>pattern</var><dd>Use <var>pattern</var> as the regexp to match.  The purpose of the <samp><span class="option">-e</span></samp>
option is to allow patterns that start with a &lsquo;<samp><span class="samp">-</span></samp>&rsquo;. 
</dl>

   <p>This version uses the <code>getopt</code> library function
(see <a href="Getopt-Function.html#Getopt-Function">Getopt Function</a>)
and the file transition library program
(see <a href="Filetrans-Function.html#Filetrans-Function">Filetrans Function</a>).

   <p>The program begins with a descriptive comment and then a <code>BEGIN</code> rule
that processes the command-line arguments with <code>getopt</code>.  The <samp><span class="option">-i</span></samp>
(ignore case) option is particularly easy with <samp><span class="command">gawk</span></samp>; we just use the
<code>IGNORECASE</code> built-in variable
(see <a href="Built_002din-Variables.html#Built_002din-Variables">Built-in Variables</a>):

   <p><a name="index-g_t_0040code_007begrep_002eawk_007d-program-1769"></a>
<pre class="example">     <!-- file eg/prog/egrep.awk -->
     # egrep.awk --- simulate egrep in awk
     <!-- endfile -->
     <!-- file eg/prog/egrep.awk -->
     # Options:
     #    -c    count of lines
     #    -s    silent - use exit value
     #    -v    invert test, success if no match
     #    -i    ignore case
     #    -l    print filenames only
     #    -e    argument is pattern
     #
     # Requires getopt and file transition library functions
     
     BEGIN {
         while ((c = getopt(ARGC, ARGV, "ce:svil")) != -1) {
             if (c == "c")
                 count_only++
             else if (c == "s")
                 no_print++
             else if (c == "v")
                 invert++
             else if (c == "i")
                 IGNORECASE = 1
             else if (c == "l")
                 filenames_only++
             else if (c == "e")
                 pattern = Optarg
             else
                 usage()
         }
     <!-- endfile -->
</pre>
   <p>Next comes the code that handles the <samp><span class="command">egrep</span></samp>-specific behavior. If no
pattern is supplied with <samp><span class="option">-e</span></samp>, the first nonoption on the
command line is used.  The <samp><span class="command">awk</span></samp> command-line arguments up to <code>ARGV[Optind]</code>
are cleared, so that <samp><span class="command">awk</span></samp> won't try to process them as files.  If no
files are specified, the standard input is used, and if multiple files are
specified, we make sure to note this so that the file names can precede the
matched lines in the output:

<pre class="example">     <!-- file eg/prog/egrep.awk -->
         if (pattern == "")
             pattern = ARGV[Optind++]
     
         for (i = 1; i &lt; Optind; i++)
             ARGV[i] = ""
         if (Optind &gt;= ARGC) {
             ARGV[1] = "-"
             ARGC = 2
         } else if (ARGC - Optind &gt; 1)
             do_filenames++
     
     #    if (IGNORECASE)
     #        pattern = tolower(pattern)
     }
     <!-- endfile -->
</pre>
   <p>The last two lines are commented out, since they are not needed in
<samp><span class="command">gawk</span></samp>.  They should be uncommented if you have to use another version
of <samp><span class="command">awk</span></samp>.

   <p>The next set of lines should be uncommented if you are not using
<samp><span class="command">gawk</span></samp>.  This rule translates all the characters in the input line
into lowercase if the <samp><span class="option">-i</span></samp> option is specified.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
The rule is
commented out since it is not necessary with <samp><span class="command">gawk</span></samp>:

<!-- Exercise: Fix this, w/array and new line as key to original line -->
<pre class="example">     <!-- file eg/prog/egrep.awk -->
     #{
     #    if (IGNORECASE)
     #        $0 = tolower($0)
     #}
     <!-- endfile -->
</pre>
   <p>The <code>beginfile</code> function is called by the rule in <samp><span class="file">ftrans.awk</span></samp>
when each new file is processed.  In this case, it is very simple; all it
does is initialize a variable <code>fcount</code> to zero. <code>fcount</code> tracks
how many lines in the current file matched the pattern
(naming the parameter <code>junk</code> shows we know that <code>beginfile</code>
is called with a parameter, but that we're not interested in its value):

<pre class="example">     <!-- file eg/prog/egrep.awk -->
     function beginfile(junk)
     {
         fcount = 0
     }
     <!-- endfile -->
</pre>
   <p>The <code>endfile</code> function is called after each file has been processed. 
It affects the output only when the user wants a count of the number of lines that
matched.  <code>no_print</code> is true only if the exit status is desired. 
<code>count_only</code> is true if line counts are desired.  <samp><span class="command">egrep</span></samp>
therefore only prints line counts if printing and counting are enabled. 
The output format must be adjusted depending upon the number of files to
process.  Finally, <code>fcount</code> is added to <code>total</code>, so that we
know the total number of lines that matched the pattern:

<pre class="example">     <!-- file eg/prog/egrep.awk -->
     function endfile(file)
     {
         if (! no_print &amp;&amp; count_only)
             if (do_filenames)
                 print file ":" fcount
             else
                 print fcount
     
         total += fcount
     }
     <!-- endfile -->
</pre>
   <p>The following rule does most of the work of matching lines. The variable
<code>matches</code> is true if the line matched the pattern. If the user
wants lines that did not match, the sense of <code>matches</code> is inverted
using the &lsquo;<samp><span class="samp">!</span></samp>&rsquo; operator. <code>fcount</code> is incremented with the value of
<code>matches</code>, which is either one or zero, depending upon a
successful or unsuccessful match.  If the line does not match, the
<code>next</code> statement just moves on to the next record.

   <p><a name="index-g_t_0040code_007b_0021_007d-_0028exclamation-point_0029_002c-_0040code_007b_0021_007d-operator-1770"></a><a name="index-exclamation-point-_0028_0040code_007b_0021_007d_0029_002c-_0040code_007b_0021_007d-operator-1771"></a>A number of additional tests are made, but they are only done if we
are not counting lines.  First, if the user only wants exit status
(<code>no_print</code> is true), then it is enough to know that <em>one</em>
line in this file matched, and we can skip on to the next file with
<code>nextfile</code>.  Similarly, if we are only printing file names, we can
print the file name, and then skip to the next file with <code>nextfile</code>. 
Finally, each line is printed, with a leading file name and colon
if necessary:

   <p><a name="index-g_t_0040code_007b_0021_007d-operator-1772"></a>
<pre class="example">     <!-- file eg/prog/egrep.awk -->
     {
         matches = ($0 ~ pattern)
         if (invert)
             matches = ! matches
     
         fcount += matches    # 1 or 0
     
         if (! matches)
             next
     
         if (! count_only) {
             if (no_print)
                 nextfile
     
             if (filenames_only) {
                 print FILENAME
                 nextfile
             }
     
             if (do_filenames)
                 print FILENAME ":" $0
             else
                 print
         }
     }
     <!-- endfile -->
</pre>
   <p>The <code>END</code> rule takes care of producing the correct exit status. If
there are no matches, the exit status is one; otherwise it is zero:

<pre class="example">     <!-- file eg/prog/egrep.awk -->
     END    \
     {
         if (total == 0)
             exit 1
         exit 0
     }
     <!-- endfile -->
</pre>
   <p>The <code>usage</code> function prints a usage message in case of invalid options,
and then exits:

<pre class="example">     <!-- file eg/prog/egrep.awk -->
     function usage(    e)
     {
         e = "Usage: egrep [-csvil] [-e pat] [files ...]"
         e = e "\n\tegrep [-csvil] pat [files ...]"
         print e &gt; "/dev/stderr"
         exit 1
     }
     <!-- endfile -->
</pre>
   <p>The variable <code>e</code> is used so that the function fits nicely
on the printed page.

   <p><a name="index-g_t_0040code_007bEND_007d-pattern_002c-backslash-continuation-and-1773"></a><a name="index-g_t_0040code_007b_005c_007d-_0028backslash_0029_002c-continuing-lines-and-1774"></a><a name="index-backslash-_0028_0040code_007b_005c_007d_0029_002c-continuing-lines-and-1775"></a>Just a note on programming style: you may have noticed that the <code>END</code>
rule uses backslash continuation, with the open brace on a line by
itself.  This is so that it more closely resembles the way functions
are written.  Many of the examples
in this chapter
use this style. You can decide for yourself if you like writing
your <code>BEGIN</code> and <code>END</code> rules this way
or not. 
<!-- ENDOFRANGE regexps -->
<!-- ENDOFRANGE sfregexp -->
<!-- ENDOFRANGE fsregexp -->

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> It
also introduces a subtle bug;
if a match happens, we output the translated line, not the original.</p>

   <hr></div>

   </body></html>

