<html lang="en">
<head>
<title>Group Functions - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Library-Functions.html#Library-Functions" title="Library Functions">
<link rel="prev" href="Passwd-Functions.html#Passwd-Functions" title="Passwd Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Group-Functions"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Passwd-Functions.html#Passwd-Functions">Passwd Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Library-Functions.html#Library-Functions">Library Functions</a>
<hr>
</div>

<h3 class="section">12.6 Reading the Group Database</h3>

<!-- STARTOFRANGE libfgdata -->
<p><a name="index-libraries-of-_0040command_007bawk_007d-functions_002c-group-database_002c-reading-1731"></a><!-- STARTOFRANGE flibgdata -->
<a name="index-functions_002c-library_002c-group-database_002c-reading-1732"></a><!-- STARTOFRANGE gdatar -->
<a name="index-group-database_002c-reading-1733"></a><!-- STARTOFRANGE datagr -->
<a name="index-database_002c-group_002c-reading-1734"></a><a name="index-g_t_0040code_007bPROCINFO_007d-array-1735"></a><a name="index-g_t_0040code_007bgetgrent_007d-function-_0028C-library_0029-1736"></a><a name="index-g_t_0040code_007bgetgrent_007d-user_002ddefined-function-1737"></a><a name="index-groups_0040comma_007b_007d-information-about-1738"></a><a name="index-account-information-1739"></a><a name="index-group-file-1740"></a><a name="index-files_002c-group-1741"></a>Much of the discussion presented in
<a href="Passwd-Functions.html#Passwd-Functions">Passwd Functions</a>,
applies to the group database as well.  Although there has traditionally
been a well-known file (<samp><span class="file">/etc/group</span></samp>) in a well-known format, the POSIX
standard only provides a set of C library routines
(<code>&lt;grp.h&gt;</code> and <code>getgrent</code>)
for accessing the information. 
Even though this file may exist, it likely does not have
complete information.  Therefore, as with the user database, it is necessary
to have a small C program that generates the group database as its output.

   <p><a name="index-g_t_0040command_007bgrcat_007d-program-1742"></a><samp><span class="command">grcat</span></samp>, a C program that &ldquo;cats&rdquo; the group database,
is as follows:

<pre class="example">     <!-- file eg/lib/grcat.c -->
     /*
      * grcat.c
      *
      * Generate a printable version of the group database
      */
     <!-- endfile -->
     <!-- file eg/lib/grcat.c -->
     #include &lt;stdio.h&gt;
     #include &lt;grp.h&gt;
     
     int
     main(argc, argv)
     int argc;
     char **argv;
     {
         struct group *g;
         int i;
     
         while ((g = getgrent()) != NULL) {
     <!-- endfile -->
     <!-- file eg/lib/grcat.c -->
             printf("%s:%s:%ld:", g-&gt;gr_name, g-&gt;gr_passwd,
                                          (long) g-&gt;gr_gid);
     <!-- endfile -->
     <!-- file eg/lib/grcat.c -->
             for (i = 0; g-&gt;gr_mem[i] != NULL; i++) {
                 printf("%s", g-&gt;gr_mem[i]);
                 if (g-&gt;gr_mem[i+1] != NULL)
                     putchar(',');
             }
             putchar('\n');
         }
         endgrent();
         return 0;
     }
     <!-- endfile -->
</pre>
   <p>Each line in the group database represents one group.  The fields are
separated with colons and represent the following information:

   <p><table summary=""><tr align="left"><td valign="top">Group name </td><td valign="top">The group's name.

<p><br></td></tr><tr align="left"><td valign="top">Group password </td><td valign="top">The group's encrypted password. In practice, this field is never used;
it is usually empty or set to &lsquo;<samp><span class="samp">*</span></samp>&rsquo;.

<p><br></td></tr><tr align="left"><td valign="top">Group-ID </td><td valign="top">
The group's numeric group ID number; this number should be unique within the file.

<p><br></td></tr><tr align="left"><td valign="top">Group member list </td><td valign="top">
A comma-separated list of user names.  These users are members of the group. 
Modern Unix systems allow users to be members of several groups
simultaneously.  If your system does, then there are elements
<code>"group1"</code> through <code>"group</code><var>N</var><code>"</code> in <code>PROCINFO</code>
for those group ID numbers. 
(Note that <code>PROCINFO</code> is a <samp><span class="command">gawk</span></samp> extension;
see <a href="Built_002din-Variables.html#Built_002din-Variables">Built-in Variables</a>.)
   <br></td></tr></table>

   <p>Here is what running <samp><span class="command">grcat</span></samp> might produce:

<pre class="example">     $ grcat
     -| wheel:*:0:arnold
     -| nogroup:*:65534:
     -| daemon:*:1:
     -| kmem:*:2:
     -| staff:*:10:arnold,miriam,andy
     -| other:*:20:
     ...
</pre>
   <p>Here are the functions for obtaining information from the group database. 
There are several, modeled after the C library functions of the same names:

   <p><a name="index-g_t_0040code_007bgetline_007d-command_002c-_0040code_007b_005fgr_005finit_007d-user_002ddefined-function-1743"></a><a name="index-g_t_0040code_007b_005fgr_005finit_007d-user_002ddefined-function-1744"></a>
<pre class="example">     <!-- file eg/lib/groupawk.in -->
     # group.awk --- functions for dealing with the group file
     <!-- endfile -->
     <!-- line break on _gr_init for smallbook -->
     <!-- file eg/lib/groupawk.in -->
     BEGIN    \
     {
         # Change to suit your system
         _gr_awklib = "/usr/local/libexec/awk/"
     }
     
     function _gr_init(    oldfs, oldrs, olddol0, grcat,
                                  using_fw, n, a, i)
     {
         if (_gr_inited)
             return
     
         oldfs = FS
         oldrs = RS
         olddol0 = $0
         using_fw = (PROCINFO["FS"] == "FIELDWIDTHS")
         FS = ":"
         RS = "\n"
     
         grcat = _gr_awklib "grcat"
         while ((grcat | getline) &gt; 0) {
             if ($1 in _gr_byname)
                 _gr_byname[$1] = _gr_byname[$1] "," $4
             else
                 _gr_byname[$1] = $0
             if ($3 in _gr_bygid)
                 _gr_bygid[$3] = _gr_bygid[$3] "," $4
             else
                 _gr_bygid[$3] = $0
     
             n = split($4, a, "[ \t]*,[ \t]*")
             for (i = 1; i &lt;= n; i++)
                 if (a[i] in _gr_groupsbyuser)
                     _gr_groupsbyuser[a[i]] = \
                         _gr_groupsbyuser[a[i]] " " $1
                 else
                     _gr_groupsbyuser[a[i]] = $1
     
             _gr_bycount[++_gr_count] = $0
         }
         close(grcat)
         _gr_count = 0
         _gr_inited++
         FS = oldfs
         if (using_fw)
             FIELDWIDTHS = FIELDWIDTHS
         RS = oldrs
         $0 = olddol0
     }
     <!-- endfile -->
</pre>
   <p>The <code>BEGIN</code> rule sets a private variable to the directory where
<samp><span class="command">grcat</span></samp> is stored.  Because it is used to help out an <samp><span class="command">awk</span></samp> library
routine, we have chosen to put it in <samp><span class="file">/usr/local/libexec/awk</span></samp>.  You might
want it to be in a different directory on your system.

   <p>These routines follow the same general outline as the user database routines
(see <a href="Passwd-Functions.html#Passwd-Functions">Passwd Functions</a>). 
The <code>_gr_inited<!-- /@w --></code> variable is used to
ensure that the database is scanned no more than once. 
The <code>_gr_init<!-- /@w --></code> function first saves <code>FS</code>, <code>FIELDWIDTHS</code>, <code>RS</code>, and
<code>$0</code>, and then sets <code>FS</code> and <code>RS</code> to the correct values for
scanning the group information.

   <p>The group information is stored is several associative arrays. 
The arrays are indexed by group name (<code>_gr_byname<!-- /@w --></code>), by group ID number
(<code>_gr_bygid<!-- /@w --></code>), and by position in the database (<code>_gr_bycount<!-- /@w --></code>). 
There is an additional array indexed by user name (<code>_gr_groupsbyuser<!-- /@w --></code>),
which is a space-separated list of groups to which each user belongs.

   <p>Unlike the user database, it is possible to have multiple records in the
database for the same group.  This is common when a group has a large number
of members.  A pair of such entries might look like the following:

<pre class="example">     tvpeople:*:101:johnny,jay,arsenio
     tvpeople:*:101:david,conan,tom,joan
</pre>
   <p>For this reason, <code>_gr_init</code> looks to see if a group name or
group ID number is already seen.  If it is, then the user names are
simply concatenated onto the previous list of users.  (There is actually a
subtle problem with the code just presented.  Suppose that
the first time there were no names. This code adds the names with
a leading comma. It also doesn't check that there is a <code>$4</code>.)

   <p>Finally, <code>_gr_init</code> closes the pipeline to <samp><span class="command">grcat</span></samp>, restores
<code>FS</code> (and <code>FIELDWIDTHS</code> if necessary), <code>RS</code>, and <code>$0</code>,
initializes <code>_gr_count</code> to zero
(it is used later), and makes <code>_gr_inited</code> nonzero.

   <p><a name="index-g_t_0040code_007bgetgrnam_007d-function-_0028C-library_0029-1745"></a>The <code>getgrnam</code> function takes a group name as its argument, and if that
group exists, it is returned. Otherwise, <code>getgrnam</code> returns the null
string:

   <p><a name="index-g_t_0040code_007bgetgrnam_007d-user_002ddefined-function-1746"></a>
<pre class="example">     <!-- file eg/lib/groupawk.in -->
     function getgrnam(group)
     {
         _gr_init()
         if (group in _gr_byname)
             return _gr_byname[group]
         return ""
     }
     <!-- endfile -->
</pre>
   <p><a name="index-g_t_0040code_007bgetgrgid_007d-function-_0028C-library_0029-1747"></a>The <code>getgrgid</code> function is similar, it takes a numeric group ID and
looks up the information associated with that group ID:

   <p><a name="index-g_t_0040code_007bgetgrgid_007d-user_002ddefined-function-1748"></a>
<pre class="example">     <!-- file eg/lib/groupawk.in -->
     function getgrgid(gid)
     {
         _gr_init()
         if (gid in _gr_bygid)
             return _gr_bygid[gid]
         return ""
     }
     <!-- endfile -->
</pre>
   <p><a name="index-g_t_0040code_007bgetgruser_007d-function-_0028C-library_0029-1749"></a>The <code>getgruser</code> function does not have a C counterpart. It takes a
user name and returns the list of groups that have the user as a member:

   <p><a name="index-g_t_0040code_007bgetgruser_007d-function_002c-user_002ddefined-1750"></a>
<pre class="example">     <!-- file eg/lib/groupawk.in -->
     function getgruser(user)
     {
         _gr_init()
         if (user in _gr_groupsbyuser)
             return _gr_groupsbyuser[user]
         return ""
     }
     <!-- endfile -->
</pre>
   <p><a name="index-g_t_0040code_007bgetgrent_007d-function-_0028C-library_0029-1751"></a>The <code>getgrent</code> function steps through the database one entry at a time. 
It uses <code>_gr_count</code> to track its position in the list:

   <p><a name="index-g_t_0040code_007bgetgrent_007d-user_002ddefined-function-1752"></a>
<pre class="example">     <!-- file eg/lib/groupawk.in -->
     function getgrent()
     {
         _gr_init()
         if (++_gr_count in _gr_bycount)
             return _gr_bycount[_gr_count]
         return ""
     }
     <!-- endfile -->
</pre>
   <!-- ENDOFRANGE clibf -->
   <p><a name="index-g_t_0040code_007bendgrent_007d-function-_0028C-library_0029-1753"></a>The <code>endgrent</code> function resets <code>_gr_count</code> to zero so that <code>getgrent</code> can
start over again:

   <p><a name="index-g_t_0040code_007bendgrent_007d-user_002ddefined-function-1754"></a>
<pre class="example">     <!-- file eg/lib/groupawk.in -->
     function endgrent()
     {
         _gr_count = 0
     }
     <!-- endfile -->
</pre>
   <p>As with the user database routines, each function calls <code>_gr_init</code> to
initialize the arrays.  Doing so only incurs the extra overhead of running
<samp><span class="command">grcat</span></samp> if these functions are used (as opposed to moving the body of
<code>_gr_init</code> into a <code>BEGIN</code> rule).

   <p>Most of the work is in scanning the database and building the various
associative arrays.  The functions that the user calls are themselves very
simple, relying on <samp><span class="command">awk</span></samp>'s associative arrays to do work.

   <p>The <samp><span class="command">id</span></samp> program in <a href="Id-Program.html#Id-Program">Id Program</a>,
uses these functions. 
<!-- ENDOFRANGE libfgdata -->
<!-- ENDOFRANGE flibgdata -->
<!-- ENDOFRANGE gdatar -->
<!-- ENDOFRANGE libf -->
<!-- ENDOFRANGE flib -->
<!-- ENDOFRANGE fudlib -->
<!-- ENDOFRANGE datagr -->

   </body></html>

