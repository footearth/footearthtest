<html lang="en">
<head>
<title>Ranges - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Pattern-Overview.html#Pattern-Overview" title="Pattern Overview">
<link rel="prev" href="Expression-Patterns.html#Expression-Patterns" title="Expression Patterns">
<link rel="next" href="BEGIN_002fEND.html#BEGIN_002fEND" title="BEGIN/END">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Ranges"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="BEGIN_002fEND.html#BEGIN_002fEND">BEGIN/END</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Expression-Patterns.html#Expression-Patterns">Expression Patterns</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Pattern-Overview.html#Pattern-Overview">Pattern Overview</a>
<hr>
</div>

<h4 class="subsection">6.1.3 Specifying Record Ranges with Patterns</h4>

<p><a name="index-range-patterns-909"></a><a name="index-patterns_002c-ranges-in-910"></a><a name="index-lines_002c-matching-ranges-of-911"></a><a name="index-g_t_0040code_007b_002c_007d-_0028comma_0029_002c-in-range-patterns-912"></a><a name="index-comma-_0028_0040code_007b_002c_007d_0029_002c-in-range-patterns-913"></a>A <dfn>range pattern</dfn> is made of two patterns separated by a comma, in
the form &lsquo;<samp><var>begpat</var><span class="samp">, </span><var>endpat</var></samp>&rsquo;.  It is used to match ranges of
consecutive input records.  The first pattern, <var>begpat</var>, controls
where the range begins, while <var>endpat</var> controls where
the pattern ends.  For example, the following:

<pre class="example">     awk '$1 == "on", $1 == "off"' myfile
</pre>
   <p class="noindent">prints every record in <samp><span class="file">myfile</span></samp> between &lsquo;<samp><span class="samp">on</span></samp>&rsquo;/&lsquo;<samp><span class="samp">off</span></samp>&rsquo; pairs, inclusive.

   <p>A range pattern starts out by matching <var>begpat</var> against every
input record.  When a record matches <var>begpat</var>, the range pattern is
<dfn>turned on</dfn> and the range pattern matches this record as well.  As long as
the range pattern stays turned on, it automatically matches every input
record read.  The range pattern also matches <var>endpat</var> against every
input record; when this succeeds, the range pattern is turned off again
for the following record.  Then the range pattern goes back to checking
<var>begpat</var> against each record.

   <p><a name="index-g_t_0040code_007bif_007d-statement_002c-actions_0040comma_007b_007d-changing-914"></a>The record that turns on the range pattern and the one that turns it
off both match the range pattern.  If you don't want to operate on
these records, you can write <code>if</code> statements in the rule's action
to distinguish them from the records you are interested in.

   <p>It is possible for a pattern to be turned on and off by the same
record. If the record satisfies both conditions, then the action is
executed for just that record. 
For example, suppose there is text between two identical markers (e.g.,
the &lsquo;<samp><span class="samp">%</span></samp>&rsquo; symbol), each on its own line, that should be ignored. 
A first attempt would be to
combine a range pattern that describes the delimited text with the
<code>next</code> statement
(not discussed yet, see <a href="Next-Statement.html#Next-Statement">Next Statement</a>). 
This causes <samp><span class="command">awk</span></samp> to skip any further processing of the current
record and start over again with the next input record. Such a program
looks like this:

<pre class="example">     /^%$/,/^%$/    { next }
                    { print }
</pre>
   <p class="noindent"><a name="index-lines_002c-skipping-between-markers-915"></a><!-- @cindex flag variables -->
This program fails because the range pattern is both turned on and turned off
by the first line, which just has a &lsquo;<samp><span class="samp">%</span></samp>&rsquo; on it.  To accomplish this task,
write the program in the following manner, using a flag:

   <p><a name="index-g_t_0040code_007b_0021_007d-operator-916"></a>
<pre class="example">     /^%$/     { skip = ! skip; next }
     skip == 1 { next } # skip lines with `skip' set
</pre>
   <p>In a range pattern, the comma (&lsquo;<samp><span class="samp">,</span></samp>&rsquo;) has the lowest precedence of
all the operators (i.e., it is evaluated last).  Thus, the following
program attempts to combine a range pattern with another, simpler test:

<pre class="example">     echo Yes | awk '/1/,/2/ || /Yes/'
</pre>
   <p>The intent of this program is &lsquo;<samp><span class="samp">(/1/,/2/) || /Yes/</span></samp>&rsquo;. 
However, <samp><span class="command">awk</span></samp> interprets this as &lsquo;<samp><span class="samp">/1/, (/2/ || /Yes/)</span></samp>&rsquo;. 
This cannot be changed or worked around; range patterns do not combine
with other patterns:

<pre class="example">     $ echo Yes | gawk '(/1/,/2/) || /Yes/'
     error--&gt; gawk: cmd. line:1: (/1/,/2/) || /Yes/
     error--&gt; gawk: cmd. line:1:           ^ parse error
     error--&gt; gawk: cmd. line:2: (/1/,/2/) || /Yes/
     error--&gt; gawk: cmd. line:2:                   ^ unexpected newline
</pre>
   </body></html>

