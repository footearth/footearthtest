<html lang="en">
<head>
<title>Regexp Field Splitting - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Field-Separators.html#Field-Separators" title="Field Separators">
<link rel="next" href="Single-Character-Fields.html#Single-Character-Fields" title="Single Character Fields">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Regexp-Field-Splitting"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Single-Character-Fields.html#Single-Character-Fields">Single Character Fields</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Field-Separators.html#Field-Separators">Field Separators</a>
<hr>
</div>

<h4 class="subsection">3.5.1 Using Regular Expressions to Separate Fields</h4>

<!-- STARTOFRANGE regexpfs -->
<p><a name="index-regular-expressions_002c-as-field-separators-413"></a><!-- STARTOFRANGE fsregexp -->
<a name="index-field-separators_002c-regular-expressions-as-414"></a>The previous subsection
discussed the use of single characters or simple strings as the
value of <code>FS</code>. 
More generally, the value of <code>FS</code> may be a string containing any
regular expression.  In this case, each match in the record for the regular
expression separates fields.  For example, the assignment:

<pre class="example">     FS = ", \t"
</pre>
   <p class="noindent">makes every area of an input line that consists of a comma followed by a
space and a TAB into a field separator.

   <p>For a less trivial example of a regular expression, try using
single spaces to separate fields the way single commas are used. 
<code>FS</code> can be set to <code>"[&nbsp;]"</code><!-- /@w --> (left bracket, space, right
bracket).  This regular expression matches a single space and nothing else
(see <a href="Regexp.html#Regexp">Regexp</a>).

   <p>There is an important difference between the two cases of &lsquo;<samp><span class="samp">FS = "&nbsp;"<!-- /@w --></span></samp>&rsquo;
(a single space) and &lsquo;<samp><span class="samp">FS = "[&nbsp;\t\n]+"<!-- /@w --></span></samp>&rsquo;
(a regular expression matching one or more spaces, TABs, or newlines). 
For both values of <code>FS</code>, fields are separated by <dfn>runs</dfn>
(multiple adjacent occurrences) of spaces, TABs,
and/or newlines.  However, when the value of <code>FS</code> is <code>"&nbsp;"</code><!-- /@w -->,
<samp><span class="command">awk</span></samp> first strips leading and trailing whitespace from
the record and then decides where the fields are. 
For example, the following pipeline prints &lsquo;<samp><span class="samp">b</span></samp>&rsquo;:

<pre class="example">     $ echo ' a b c d ' | awk '{ print $2 }'
     -| b
</pre>
   <p class="noindent">However, this pipeline prints &lsquo;<samp><span class="samp">a</span></samp>&rsquo; (note the extra spaces around
each letter):

<pre class="example">     $ echo ' a  b  c  d ' | awk 'BEGIN { FS = "[ \t\n]+" }
     &gt;                                  { print $2 }'
     -| a
</pre>
   <p class="noindent"><a name="index-null-strings-415"></a><a name="index-strings_002c-null-416"></a><a name="index-empty-strings_002c-See-null-strings-417"></a>In this case, the first field is <dfn>null</dfn> or empty.

   <p>The stripping of leading and trailing whitespace also comes into
play whenever <code>$0</code> is recomputed.  For instance, study this pipeline:

<pre class="example">     $ echo '   a b c d' | awk '{ print; $2 = $2; print }'
     -|    a b c d
     -| a b c d
</pre>
   <p class="noindent">The first <code>print</code> statement prints the record as it was read,
with leading whitespace intact.  The assignment to <code>$2</code> rebuilds
<code>$0</code> by concatenating <code>$1</code> through <code>$NF</code> together,
separated by the value of <code>OFS</code>.  Because the leading whitespace
was ignored when finding <code>$1</code>, it is not part of the new <code>$0</code>. 
Finally, the last <code>print</code> statement prints the new <code>$0</code>.

   <p><a name="index-g_t_0040code_007bFS_007d_002c-containing-_0040samp_007b_005e_007d-418"></a><a name="index-g_t_0040samp_007b_005e_007d_002c-in-_0040code_007bFS_007d-419"></a><a name="index-dark-corner_002c-_0040samp_007b_005e_007d_002c-in-_0040code_007bFS_007d-420"></a>There is an additional subtlety to be aware of when using regular exressions
for field splitting. 
It is not well-specified in the POSIX standard, or anywhere else, what &lsquo;<samp><span class="samp">^</span></samp>&rsquo;
means when splitting fields.  Does the &lsquo;<samp><span class="samp">^</span></samp>&rsquo;  match only at the beginning of
the entire record? Or is each field separator a new string?  It turns out that
different <samp><span class="command">awk</span></samp> versions answer this question differently, and you
should not rely on any specific behavior in your programs. 
(d.c.)

   <p>As a point of information, the Bell Labs <samp><span class="command">awk</span></samp> allows &lsquo;<samp><span class="samp">^</span></samp>&rsquo;
to match only at the beginning of the record.  Versions of <samp><span class="command">gawk</span></samp>
after 3.1.6 also work this way. For example:

<pre class="example">     $  echo 'xxAA  xxBxx  C' |
     &gt; nawk -F '(^x+)|( +)' '{ for (i = 1; i &lt;= NF; i++) printf "--&gt;%s&lt;--\n", $i }'
     -| --&gt;&lt;--
     -| --&gt;AA&lt;--
     -| --&gt;xxBxx&lt;--
     -| --&gt;C&lt;--
     
     $  echo 'xxAA  xxBxx  C' |
     &gt; gawk-3.1.6 -F '(^x+)|( +)' '{ for (i = 1; i &lt;= NF; i++) printf "--&gt;%s&lt;--\n", $i }'
     -| --&gt;&lt;--
     -| --&gt;AA&lt;--
     -| --&gt;&lt;--
     -| --&gt;Bxx&lt;--
     -| --&gt;C&lt;--
</pre>
   <p class="noindent">As mentioned, <samp><span class="command">gawk</span></samp> now behaves like the Bell Labs <samp><span class="command">awk</span></samp>. 
<!-- ENDOFRANGE regexpfs -->
<!-- ENDOFRANGE fsregexp -->

   </body></html>

