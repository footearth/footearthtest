<html lang="en">
<head>
<title>Bitwise Functions - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Built_002din.html#Built_002din" title="Built-in">
<link rel="prev" href="Time-Functions.html#Time-Functions" title="Time Functions">
<link rel="next" href="I18N-Functions.html#I18N-Functions" title="I18N Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Bitwise-Functions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="I18N-Functions.html#I18N-Functions">I18N Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Time-Functions.html#Time-Functions">Time Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Built_002din.html#Built_002din">Built-in</a>
<hr>
</div>

<h4 class="subsection">8.1.6 Bit-Manipulation Functions of <samp><span class="command">gawk</span></samp></h4>

<!-- STARTOFRANGE bit -->
<p><a name="index-bitwise_002c-operations-1252"></a><!-- STARTOFRANGE and -->
<a name="index-AND-bitwise-operation-1253"></a><!-- STARTOFRANGE oro -->
<a name="index-OR-bitwise-operation-1254"></a><!-- STARTOFRANGE xor -->
<a name="index-XOR-bitwise-operation-1255"></a><!-- STARTOFRANGE opbit -->
<a name="index-operations_002c-bitwise-1256"></a><blockquote>
<i>I can explain it for you, but I can't understand it for you.</i><br>
Anonymous
</blockquote>

   <p>Many languages provide the ability to perform <dfn>bitwise</dfn> operations
on two integer numbers.  In other words, the operation is performed on
each successive pair of bits in the operands. 
Three common operations are bitwise AND, OR, and XOR. 
The operations are described in <a href="table_002dbitwise_002dops.html#table_002dbitwise_002dops">table-bitwise-ops</a>.

   <div class="float">
<a name="table_002dbitwise_002dops"></a>
<pre class="display">                     Bit Operator
               |  AND  |   OR  |  XOR
               |&mdash;+&mdash;+&mdash;+&mdash;+&mdash;+&mdash;
     Operands  | 0 | 1 | 0 | 1 | 0 | 1
     &mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;+&mdash;+&mdash;+&mdash;+&mdash;+&mdash;
         0     | 0   0 | 0   1 | 0   1
         1     | 0   1 | 1   1 | 1   0
</pre>
   <p><strong class="float-caption">Table 8.6: Bitwise Operations</strong></p></div>

   <p><a name="index-bitwise_002c-complement-1257"></a><a name="index-complement_002c-bitwise-1258"></a>As you can see, the result of an AND operation is 1 only when <em>both</em>
bits are 1. 
The result of an OR operation is 1 if <em>either</em> bit is 1. 
The result of an XOR operation is 1 if either bit is 1,
but not both. 
The next operation is the <dfn>complement</dfn>; the complement of 1 is 0 and
the complement of 0 is 1. Thus, this operation &ldquo;flips&rdquo; all the bits
of a given value.

   <p><a name="index-bitwise_002c-shift-1259"></a><a name="index-left-shift_002c-bitwise-1260"></a><a name="index-right-shift_002c-bitwise-1261"></a><a name="index-shift_002c-bitwise-1262"></a>Finally, two other common operations are to shift the bits left or right. 
For example, if you have a bit string &lsquo;<samp><span class="samp">10111001</span></samp>&rsquo; and you shift it
right by three bits, you end up with &lsquo;<samp><span class="samp">00010111</span></samp>&rsquo;.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
<!-- Purposely decided to use   0's   and   1's   here.  2/2001. -->
If you start over
again with &lsquo;<samp><span class="samp">10111001</span></samp>&rsquo; and shift it left by three bits, you end up
with &lsquo;<samp><span class="samp">11001000</span></samp>&rsquo;. 
<samp><span class="command">gawk</span></samp> provides built-in functions that implement the
bitwise operations just described. They are:

   <p><a name="index-g_t_0040command_007bgawk_007d_002c-bitwise-operations-in-1263"></a>
   <p><table summary=""><a name="index-g_t_0040code_007band_007d-function-_0028_0040command_007bgawk_007d_0029-1264"></a><tr align="left"><td valign="top"><code>and(</code><var>v1</var><code>, </code><var>v2</var><code>)</code>
</td><td valign="top">Returns the bitwise AND of the values provided by <var>v1</var> and <var>v2</var>.

<p><a name="index-g_t_0040code_007bor_007d-function-_0028_0040command_007bgawk_007d_0029-1265"></a><br></td></tr><tr align="left"><td valign="top"><code>or(</code><var>v1</var><code>, </code><var>v2</var><code>)</code>
</td><td valign="top">Returns the bitwise OR of the values provided by <var>v1</var> and <var>v2</var>.

<p><a name="index-g_t_0040code_007bxor_007d-function-_0028_0040command_007bgawk_007d_0029-1266"></a><br></td></tr><tr align="left"><td valign="top"><code>xor(</code><var>v1</var><code>, </code><var>v2</var><code>)</code>
</td><td valign="top">Returns the bitwise XOR of the values provided by <var>v1</var> and <var>v2</var>.

<p><a name="index-g_t_0040code_007bcompl_007d-function-_0028_0040command_007bgawk_007d_0029-1267"></a><br></td></tr><tr align="left"><td valign="top"><code>compl(</code><var>val</var><code>)</code>
</td><td valign="top">Returns the bitwise complement of <var>val</var>.

<p><a name="index-g_t_0040code_007blshift_007d-function-_0028_0040command_007bgawk_007d_0029-1268"></a><br></td></tr><tr align="left"><td valign="top"><code>lshift(</code><var>val</var><code>, </code><var>count</var><code>)</code>
</td><td valign="top">Returns the value of <var>val</var>, shifted left by <var>count</var> bits.

<p><a name="index-g_t_0040code_007brshift_007d-function-_0028_0040command_007bgawk_007d_0029-1269"></a><br></td></tr><tr align="left"><td valign="top"><code>rshift(</code><var>val</var><code>, </code><var>count</var><code>)</code>
</td><td valign="top">Returns the value of <var>val</var>, shifted right by <var>count</var> bits.
   <br></td></tr></table>

   <p>For all of these functions, first the double-precision floating-point value is
converted to the widest C unsigned integer type, then the bitwise operation is
performed.  If the result cannot be represented exactly as a C <code>double</code>,
leading nonzero bits are removed one by one until it can be represented
exactly.  The result is then converted back into a C <code>double</code>.  (If
you don't understand this paragraph, don't worry about it.)

   <p>Here is a user-defined function
(see <a href="User_002ddefined.html#User_002ddefined">User-defined</a>)
that illustrates the use of these functions:

   <p><a name="index-g_t_0040code_007bbits2str_007d-user_002ddefined-function-1270"></a><a name="index-g_t_0040code_007btestbits_002eawk_007d-program-1271"></a>
<pre class="smallexample">     <!-- file eg/lib/bits2str.awk -->
     # bits2str --- turn a byte into readable 1's and 0's
     
     function bits2str(bits,        data, mask)
     {
         if (bits == 0)
             return "0"
     
         mask = 1
         for (; bits != 0; bits = rshift(bits, 1))
             data = (and(bits, mask) ? "1" : "0") data
     
         while ((length(data) % 8) != 0)
             data = "0" data
     
         return data
     }
     <!-- endfile -->
     
     <!-- this is a hack to make testbits.awk self-contained -->
     <!-- file eg/prog/testbits.awk -->
     BEGIN {
         printf "123 = %s\n", bits2str(123)
         printf "0123 = %s\n", bits2str(0123)
         printf "0x99 = %s\n", bits2str(0x99)
         comp = compl(0x99)
         printf "compl(0x99) = %#x = %s\n", comp, bits2str(comp)
         shift = lshift(0x99, 2)
         printf "lshift(0x99, 2) = %#x = %s\n", shift, bits2str(shift)
         shift = rshift(0x99, 2)
         printf "rshift(0x99, 2) = %#x = %s\n", shift, bits2str(shift)
     }
     <!-- endfile -->
</pre>
   <p class="noindent">This program produces the following output when run:

<pre class="smallexample">     $ gawk -f testbits.awk
     -| 123 = 01111011
     -| 0123 = 01010011
     -| 0x99 = 10011001
     -| compl(0x99) = 0xffffff66 = 11111111111111111111111101100110
     -| lshift(0x99, 2) = 0x264 = 0000001001100100
     -| rshift(0x99, 2) = 0x26 = 00100110
</pre>
   <p><a name="index-numbers_002c-converting_002c-to-strings-1272"></a><a name="index-strings_002c-converting_002c-numbers-to-1273"></a><a name="index-converting_002c-numbers_002c-to-strings-1274"></a>The <code>bits2str</code> function turns a binary number into a string. 
The number <code>1</code> represents a binary value where the rightmost bit
is set to 1.  Using this mask,
the function repeatedly checks the rightmost bit. 
ANDing the mask with the value indicates whether the
rightmost bit is 1 or not. If so, a <code>"1"</code> is concatenated onto the front
of the string. 
Otherwise, a <code>"0"</code> is added. 
The value is then shifted right by one bit and the loop continues
until there are no more 1 bits.

   <p>If the initial value is zero it returns a simple <code>"0"</code>. 
Otherwise, at the end, it pads the value with zeros to represent multiples
of 8-bit quantities. This is typical in modern computers.

   <p>The main code in the <code>BEGIN</code> rule shows the difference between the
decimal and octal values for the same numbers
(see <a href="Nondecimal_002dnumbers.html#Nondecimal_002dnumbers">Nondecimal-numbers</a>),
and then demonstrates the
results of the <code>compl</code>, <code>lshift</code>, and <code>rshift</code> functions. 
<!-- ENDOFRANGE bit -->
<!-- ENDOFRANGE and -->
<!-- ENDOFRANGE oro -->
<!-- ENDOFRANGE xor -->
<!-- ENDOFRANGE opbit -->

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> This example
shows that 0's come in on the left side. For <samp><span class="command">gawk</span></samp>, this is
always true, but in some languages, it's possible to have the left side
fill with 1's. Caveat emptor.</p>

   <hr></div>

   </body></html>

