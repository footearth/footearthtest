<html lang="en">
<head>
<title>Igawk Program - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Miscellaneous-Programs.html#Miscellaneous-Programs" title="Miscellaneous Programs">
<link rel="prev" href="Simple-Sed.html#Simple-Sed" title="Simple Sed">
<link rel="next" href="Signature-Program.html#Signature-Program" title="Signature Program">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Igawk-Program"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Signature-Program.html#Signature-Program">Signature Program</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Simple-Sed.html#Simple-Sed">Simple Sed</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Miscellaneous-Programs.html#Miscellaneous-Programs">Miscellaneous Programs</a>
<hr>
</div>

<h4 class="subsection">13.3.9 An Easy Way to Use Library Functions</h4>

<!-- STARTOFRANGE libfex -->
<p><a name="index-libraries-of-_0040command_007bawk_007d-functions_002c-example-program-for-using-1831"></a><!-- STARTOFRANGE flibex -->
<a name="index-functions_002c-library_002c-example-program-for-using-1832"></a>Using library functions in <samp><span class="command">awk</span></samp> can be very beneficial. It
encourages code reuse and the writing of general functions. Programs are
smaller and therefore clearer. 
However, using library functions is only easy when writing <samp><span class="command">awk</span></samp>
programs; it is painful when running them, requiring multiple <samp><span class="option">-f</span></samp>
options.  If <samp><span class="command">gawk</span></samp> is unavailable, then so too is the <samp><span class="env">AWKPATH</span></samp>
environment variable and the ability to put <samp><span class="command">awk</span></samp> functions into a
library directory (see <a href="Options.html#Options">Options</a>). 
It would be nice to be able to write programs in the following manner:

<pre class="example">     # library functions
     @include getopt.awk
     @include join.awk
     ...
     
     # main program
     BEGIN {
         while ((c = getopt(ARGC, ARGV, "a:b:cde")) != -1)
             ...
         ...
     }
</pre>
   <p>The following program, <samp><span class="file">igawk.sh</span></samp>, provides this service. 
It simulates <samp><span class="command">gawk</span></samp>'s searching of the <samp><span class="env">AWKPATH</span></samp> variable
and also allows <dfn>nested</dfn> includes; i.e., a file that is included
with &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; can contain further &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; statements. 
<samp><span class="command">igawk</span></samp> makes an effort to only include files once, so that nested
includes don't accidentally include a library function twice.

   <p><samp><span class="command">igawk</span></samp> should behave just like <samp><span class="command">gawk</span></samp> externally.  This
means it should accept all of <samp><span class="command">gawk</span></samp>'s command-line arguments,
including the ability to have multiple source files specified via
<samp><span class="option">-f</span></samp>, and the ability to mix command-line and library source files.

   <p>The program is written using the POSIX Shell (<samp><span class="command">sh</span></samp>) command
language.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a> It works as follows:

     <ol type=1 start=1>
<li>Loop through the arguments, saving anything that doesn't represent
<samp><span class="command">awk</span></samp> source code for later, when the expanded program is run.

     <li>For any arguments that do represent <samp><span class="command">awk</span></samp> text, put the arguments into
a shell variable that will be expanded.  There are two cases:

          <ol type=a start=1>
<li>Literal text, provided with <samp><span class="option">--source</span></samp> or <samp><span class="option">--source=</span></samp>.  This
text is just appended directly.

          <li>Source file names, provided with <samp><span class="option">-f</span></samp>.  We use a neat trick and append
&lsquo;<samp><span class="samp">@include </span><var>filename</var></samp>&rsquo; to the shell variable's contents.  Since the file-inclusion
program works the way <samp><span class="command">gawk</span></samp> does, this gets the text
of the file included into the program at the correct point.
          </ol>

     <li>Run an <samp><span class="command">awk</span></samp> program (naturally) over the shell variable's contents to expand
&lsquo;<samp><span class="samp">@include</span></samp>&rsquo; statements.  The expanded program is placed in a second
shell variable.

     <li>Run the expanded program with <samp><span class="command">gawk</span></samp> and any other original command-line
arguments that the user supplied (such as the data file names).
        </ol>

   <p>This program uses shell variables extensively; for storing command line arguments,
the text of the <samp><span class="command">awk</span></samp> program that will expand the user's program, for the
user's original program, and for the expanded program.  Doing so removes some
potential problems that might arise were we to use temporary files instead,
at the cost of making the script somewhat more complicated.

   <p>The initial part of the program turns on shell tracing if the first
argument is &lsquo;<samp><span class="samp">debug</span></samp>&rsquo;.

   <p>The next part loops through all the command-line arguments. 
There are several cases of interest:

     <dl>
<dt><code>--</code><dd>This ends the arguments to <samp><span class="command">igawk</span></samp>.  Anything else should be passed on
to the user's <samp><span class="command">awk</span></samp> program without being evaluated.

     <br><dt><code>-W</code><dd>This indicates that the next option is specific to <samp><span class="command">gawk</span></samp>.  To make
argument processing easier, the <samp><span class="option">-W</span></samp> is appended to the front of the
remaining arguments and the loop continues.  (This is an <samp><span class="command">sh</span></samp>
programming trick.  Don't worry about it if you are not familiar with
<samp><span class="command">sh</span></samp>.)

     <br><dt><code>-v</code><span class="roman">,</span><code> -F</code><dd>These are saved and passed on to <samp><span class="command">gawk</span></samp>.

     <br><dt><code>-f</code><span class="roman">,</span><code> --file</code><span class="roman">,</span><code> --file=</code><span class="roman">,</span><code> -Wfile=</code><dd>The file name is appended to the shell variable <code>program</code> with an
&lsquo;<samp><span class="samp">@include</span></samp>&rsquo; statement. 
The <samp><span class="command">expr</span></samp> utility is used to remove the leading option part of the
argument (e.g., &lsquo;<samp><span class="samp">--file=</span></samp>&rsquo;). 
(Typical <samp><span class="command">sh</span></samp> usage would be to use the <samp><span class="command">echo</span></samp> and <samp><span class="command">sed</span></samp>
utilities to do this work.  Unfortunately, some versions of <samp><span class="command">echo</span></samp> evaluate
escape sequences in their arguments, possibly mangling the program text. 
Using <samp><span class="command">expr</span></samp> avoids this problem.)

     <br><dt><code>--source</code><span class="roman">,</span><code> --source=</code><span class="roman">,</span><code> -Wsource=</code><dd>The source text is appended to <code>program</code>.

     <br><dt><code>--version</code><span class="roman">,</span><code> -Wversion</code><dd><samp><span class="command">igawk</span></samp> prints its version number, runs &lsquo;<samp><span class="samp">gawk --version</span></samp>&rsquo;
to get the <samp><span class="command">gawk</span></samp> version information, and then exits. 
</dl>

   <p>If none of the <samp><span class="option">-f</span></samp>, <samp><span class="option">--file</span></samp>, <samp><span class="option">-Wfile</span></samp>, <samp><span class="option">--source</span></samp>,
or <samp><span class="option">-Wsource</span></samp> arguments are supplied, then the first nonoption argument
should be the <samp><span class="command">awk</span></samp> program.  If there are no command-line
arguments left, <samp><span class="command">igawk</span></samp> prints an error message and exits. 
Otherwise, the first argument is appended to <code>program</code>. 
In any case, after the arguments have been processed,
<code>program</code> contains the complete text of the original <samp><span class="command">awk</span></samp>
program.

   <p>The program is as follows:

   <p><a name="index-g_t_0040code_007bigawk_002esh_007d-program-1833"></a>
<pre class="example">     <!-- file eg/prog/igawk.sh -->
     #! /bin/sh
     # igawk --- like gawk but do @include processing
     <!-- endfile -->
     <!-- file eg/prog/igawk.sh -->
     if [ "$1" = debug ]
     then
         set -x
         shift
     fi
     
     # A literal newline, so that program text is formatted correctly
     n='
     '
     
     # Initialize variables to empty
     program=
     opts=
     
     while [ $# -ne 0 ] # loop over arguments
     do
         case $1 in
         --)     shift; break;;
     
         -W)     shift
                 # The ${x?'message here'} construct prints a
                 # diagnostic if $x is the null string
                 set -- -W"${@?'missing operand'}"
                 continue;;
     
         -[vF])  opts="$opts $1 '${2?'missing operand'}'"
                 shift;;
     
         -[vF]*) opts="$opts '$1'" ;;
     
         -f)     program="$program$n@include ${2?'missing operand'}"
                 shift;;
     
         -f*)    f=`expr "$1" : '-f\(.*\)'`
                 program="$program$n@include $f";;
     
         -[W-]file=*)
                 f=`expr "$1" : '-.file=\(.*\)'`
                 program="$program$n@include $f";;
     
         -[W-]file)
                 program="$program$n@include ${2?'missing operand'}"
                 shift;;
     
         -[W-]source=*)
                 t=`expr "$1" : '-.source=\(.*\)'`
                 program="$program$n$t";;
     
         -[W-]source)
                 program="$program$n${2?'missing operand'}"
                 shift;;
     
         -[W-]version)
                 echo igawk: version 2.0 1&gt;&amp;2
                 gawk --version
                 exit 0 ;;
     
         -[W-]*) opts="$opts '$1'" ;;
     
         *)      break;;
         esac
         shift
     done
     
     if [ -z "$program" ]
     then
          program=${1?'missing program'}
          shift
     fi
     
     # At this point, `program' has the program.
     <!-- endfile -->
</pre>
   <p>The <samp><span class="command">awk</span></samp> program to process &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; directives
is stored in the shell variable <code>expand_prog</code>.  Doing this keeps
the shell script readable.  The <samp><span class="command">awk</span></samp> program
reads through the user's program, one line at a time, using <code>getline</code>
(see <a href="Getline.html#Getline">Getline</a>).  The input
file names and &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; statements are managed using a stack. 
As each &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; is encountered, the current file name is
&ldquo;pushed&rdquo; onto the stack and the file named in the &lsquo;<samp><span class="samp">@include</span></samp>&rsquo;
directive becomes the current file name.  As each file is finished,
the stack is &ldquo;popped,&rdquo; and the previous input file becomes the current
input file again.  The process is started by making the original file
the first one on the stack.

   <p>The <code>pathto</code> function does the work of finding the full path to
a file.  It simulates <samp><span class="command">gawk</span></samp>'s behavior when searching the
<samp><span class="env">AWKPATH</span></samp> environment variable
(see <a href="AWKPATH-Variable.html#AWKPATH-Variable">AWKPATH Variable</a>). 
If a file name has a &lsquo;<samp><span class="samp">/</span></samp>&rsquo; in it, no path search is done. Otherwise,
the file name is concatenated with the name of each directory in
the path, and an attempt is made to open the generated file name. 
The only way to test if a file can be read in <samp><span class="command">awk</span></samp> is to go
ahead and try to read it with <code>getline</code>; this is what <code>pathto</code>
does.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a> If the file can be read, it is closed and the file name
is returned:

<pre class="example">     <!-- file eg/prog/igawk.sh -->
     expand_prog='
     
     function pathto(file,    i, t, junk)
     {
         if (index(file, "/") != 0)
             return file
     
         for (i = 1; i &lt;= ndirs; i++) {
             t = (pathlist[i] "/" file)
             if ((getline junk &lt; t) &gt; 0) {
                 # found it
                 close(t)
                 return t
             }
         }
         return ""
     }
     <!-- endfile -->
</pre>
   <p>The main program is contained inside one <code>BEGIN</code> rule.  The first thing it
does is set up the <code>pathlist</code> array that <code>pathto</code> uses.  After
splitting the path on &lsquo;<samp><span class="samp">:</span></samp>&rsquo;, null elements are replaced with <code>"."</code>,
which represents the current directory:

<pre class="example">     <!-- file eg/prog/igawk.sh -->
     BEGIN {
         path = ENVIRON["AWKPATH"]
         ndirs = split(path, pathlist, ":")
         for (i = 1; i &lt;= ndirs; i++) {
             if (pathlist[i] == "")
                 pathlist[i] = "."
         }
     <!-- endfile -->
</pre>
   <p>The stack is initialized with <code>ARGV[1]</code>, which will be <samp><span class="file">/dev/stdin</span></samp>. 
The main loop comes next.  Input lines are read in succession. Lines that
do not start with &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; are printed verbatim. 
If the line does start with &lsquo;<samp><span class="samp">@include</span></samp>&rsquo;, the file name is in <code>$2</code>. 
<code>pathto</code> is called to generate the full path.  If it cannot, then we
print an error message and continue.

   <p>The next thing to check is if the file is included already.  The
<code>processed</code> array is indexed by the full file name of each included
file and it tracks this information for us.  If the file is
seen again, a warning message is printed. Otherwise, the new file name is
pushed onto the stack and processing continues.

   <p>Finally, when <code>getline</code> encounters the end of the input file, the file
is closed and the stack is popped.  When <code>stackptr</code> is less than zero,
the program is done:

<pre class="example">     <!-- file eg/prog/igawk.sh -->
         stackptr = 0
         input[stackptr] = ARGV[1] # ARGV[1] is first file
     
         for (; stackptr &gt;= 0; stackptr--) {
             while ((getline &lt; input[stackptr]) &gt; 0) {
                 if (tolower($1) != "@include") {
                     print
                     continue
                 }
                 fpath = pathto($2)
                 if (fpath == "") {
                     printf("igawk:%s:%d: cannot find %s\n",
                         input[stackptr], FNR, $2) &gt; "/dev/stderr"
                     continue
                 }
                 if (! (fpath in processed)) {
                     processed[fpath] = input[stackptr]
                     input[++stackptr] = fpath  # push onto stack
                 } else
                     print $2, "included in", input[stackptr],
                         "already included in",
                         processed[fpath] &gt; "/dev/stderr"
             }
             close(input[stackptr])
         }
     }'  # close quote ends `expand_prog' variable
     
     processed_program=`gawk -- "$expand_prog" /dev/stdin &lt;&lt;EOF
     $program
     EOF
     `
     <!-- endfile -->
</pre>
   <p>The shell construct &lsquo;<samp><var>command</var><span class="samp"> &lt;&lt; </span><var>marker</var></samp>&rsquo; is called a <dfn>here document</dfn>. 
Everything in the shell script up to the <var>marker</var> is fed to <var>command</var> as input. 
The shell processes the contents of the here document for variable and command substitution
(and possibly other things as well, depending upon the shell).

   <p>The shell construct &lsquo;<samp><span class="samp">`...`</span></samp>&rsquo; is called <dfn>command substitution</dfn>. 
The output of the command between the two backquotes (grave accents) is substituted
into the command line.  It is saved as a single string, even if the results
contain whitespace.

   <p>The expanded program is saved in the variable <code>processed_program</code>. 
It's done in these steps:

     <ol type=1 start=1>
<li>Run <samp><span class="command">gawk</span></samp> with the &lsquo;<samp><span class="samp">@include</span></samp>&rsquo;-processing program (the
value of the <code>expand_prog</code> shell variable) on standard input.

     <li>Standard input is the contents of the user's program, from the shell variable <code>program</code>. 
Its contents are fed to <samp><span class="command">gawk</span></samp> via a here document.

     <li>The results of this processing are saved in the shell variable <code>processed_program</code> by using command substitution.
        </ol>

   <p>The last step is to call <samp><span class="command">gawk</span></samp> with the expanded program,
along with the original
options and command-line arguments that the user supplied.

<!-- this causes more problems than it solves, so leave it out. -->
<pre class="example">     <!-- file eg/prog/igawk.sh -->
     eval gawk $opts -- '"$processed_program"' '"$@"'
     <!-- endfile -->
</pre>
   <p>The <samp><span class="command">eval</span></samp> command is a shell construct that reruns the shell's parsing
process.  This keeps things properly quoted.

   <p>This version of <samp><span class="command">igawk</span></samp> represents my fourth attempt at this program. 
There are four key simplifications that make the program work better:

     <ul>
<li>Using &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; even for the files named with <samp><span class="option">-f</span></samp> makes building
the initial collected <samp><span class="command">awk</span></samp> program much simpler; all the
&lsquo;<samp><span class="samp">@include</span></samp>&rsquo; processing can be done once.

     <li>Not trying to save the line read with <code>getline</code>
in the <code>pathto</code> function when testing for the
file's accessibility for use with the main program simplifies things
considerably. 
<!-- what problem does this engender though - exercise -->
<!-- answer, reading from "-" or /dev/stdin -->

     <li>Using a <code>getline</code> loop in the <code>BEGIN</code> rule does it all in one
place.  It is not necessary to call out to a separate loop for processing
nested &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; statements.

     <li>Instead of saving the expanded program in a temporary file, putting it in a shell variable
avoids some potential security problems. 
This has the disadvantage that the script relies upon more features
of the <samp><span class="command">sh</span></samp> language, making it harder to follow for those who
aren't familiar with <samp><span class="command">sh</span></samp>. 
</ul>

   <p>Also, this program illustrates that it is often worthwhile to combine
<samp><span class="command">sh</span></samp> and <samp><span class="command">awk</span></samp> programming together.  You can usually
accomplish quite a lot, without having to resort to low-level programming
in C or C++, and it is frequently easier to do certain kinds of string
and argument manipulation using the shell than it is in <samp><span class="command">awk</span></samp>.

   <p>Finally, <samp><span class="command">igawk</span></samp> shows that it is not always necessary to add new
features to a program; they can often be layered on top.  With <samp><span class="command">igawk</span></samp>,
there is no real reason to build &lsquo;<samp><span class="samp">@include</span></samp>&rsquo; processing into
<samp><span class="command">gawk</span></samp> itself.

   <p><a name="index-search-paths_002c-for-source-files-1834"></a><a name="index-source-files_0040comma_007b_007d-search-path-for-1835"></a><a name="index-files_002c-source_0040comma_007b_007d-search-path-for-1836"></a><a name="index-directories_002c-searching-1837"></a>As an additional example of this, consider the idea of having two
files in a directory in the search path:

     <dl>
<dt><samp><span class="file">default.awk</span></samp><dd>This file contains a set of default library functions, such
as <code>getopt</code> and <code>assert</code>.

     <br><dt><samp><span class="file">site.awk</span></samp><dd>This file contains library functions that are specific to a site or
installation; i.e., locally developed functions. 
Having a separate file allows <samp><span class="file">default.awk</span></samp> to change with
new <samp><span class="command">gawk</span></samp> releases, without requiring the system administrator to
update it each time by adding the local functions. 
</dl>

   <p>One user
<!-- Karl Berry, karl@ileaf.com, 10/95 -->
suggested that <samp><span class="command">gawk</span></samp> be modified to automatically read these files
upon startup.  Instead, it would be very simple to modify <samp><span class="command">igawk</span></samp>
to do this. Since <samp><span class="command">igawk</span></samp> can process nested &lsquo;<samp><span class="samp">@include</span></samp>&rsquo;
directives, <samp><span class="file">default.awk</span></samp> could simply contain &lsquo;<samp><span class="samp">@include</span></samp>&rsquo;
statements for the desired library functions.

<!-- Exercise: make this change -->
<!-- ENDOFRANGE libfex -->
<!-- ENDOFRANGE flibex -->
<!-- ENDOFRANGE awkpex -->
   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Fully explaining the <samp><span class="command">sh</span></samp> language is beyond
the scope of this book. We provide some minimal explanations, but see
a good shell programming book if you wish to understand things in more
depth.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> On some very old versions of <samp><span class="command">awk</span></samp>, the test
&lsquo;<samp><span class="samp">getline junk &lt; t</span></samp>&rsquo; can loop forever if the file exists but is empty. 
Caveat emptor.</p>

   <hr></div>

   </body></html>

