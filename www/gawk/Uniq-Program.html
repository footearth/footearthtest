<html lang="en">
<head>
<title>Uniq Program - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Clones.html#Clones" title="Clones">
<link rel="prev" href="Tee-Program.html#Tee-Program" title="Tee Program">
<link rel="next" href="Wc-Program.html#Wc-Program" title="Wc Program">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Uniq-Program"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Wc-Program.html#Wc-Program">Wc Program</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Tee-Program.html#Tee-Program">Tee Program</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Clones.html#Clones">Clones</a>
<hr>
</div>

<h4 class="subsection">13.2.6 Printing Nonduplicated Lines of Text</h4>

<!-- STARTOFRANGE prunt -->
<p><a name="index-printing_002c-unduplicated-lines-of-text-1789"></a><!-- STARTOFRANGE tpul -->
<a name="index-text_0040comma_007b_007d-printing_002c-unduplicated-lines-of-1790"></a><a name="index-g_t_0040command_007buniq_007d-utility-1791"></a>The <samp><span class="command">uniq</span></samp> utility reads sorted lines of data on its standard
input, and by default removes duplicate lines.  In other words, it only
prints unique lines&mdash;hence the name.  <samp><span class="command">uniq</span></samp> has a number of
options. The usage is as follows:

<pre class="example">     uniq <span class="roman">[</span>-udc <span class="roman">[</span>-<var>n</var><span class="roman">]]</span> <span class="roman">[</span>+<var>n</var><span class="roman">]</span> <span class="roman">[</span> <var>input file</var> <span class="roman">[</span> <var>output file</var> <span class="roman">]]</span>
</pre>
   <p>The options for <samp><span class="command">uniq</span></samp> are:

     <dl>
<dt><code>-d</code><dd>Pnly print only repeated lines.

     <br><dt><code>-u</code><dd>Print only nonrepeated lines.

     <br><dt><code>-c</code><dd>Count lines. This option overrides <samp><span class="option">-d</span></samp> and <samp><span class="option">-u</span></samp>.  Both repeated
and nonrepeated lines are counted.

     <br><dt><code>-</code><var>n</var><dd>Skip <var>n</var> fields before comparing lines.  The definition of fields
is similar to <samp><span class="command">awk</span></samp>'s default: nonwhitespace characters separated
by runs of spaces and/or TABs.

     <br><dt><code>+</code><var>n</var><dd>Skip <var>n</var> characters before comparing lines.  Any fields specified with
&lsquo;<samp><span class="samp">-</span><var>n</var></samp>&rsquo; are skipped first.

     <br><dt><var>input file</var><dd>Data is read from the input file named on the command line, instead of from
the standard input.

     <br><dt><var>output file</var><dd>The generated output is sent to the named output file, instead of to the
standard output. 
</dl>

   <p>Normally <samp><span class="command">uniq</span></samp> behaves as if both the <samp><span class="option">-d</span></samp> and
<samp><span class="option">-u</span></samp> options are provided.

   <p><samp><span class="command">uniq</span></samp> uses the
<code>getopt</code> library function
(see <a href="Getopt-Function.html#Getopt-Function">Getopt Function</a>)
and the <code>join</code> library function
(see <a href="Join-Function.html#Join-Function">Join Function</a>).

   <p>The program begins with a <code>usage</code> function and then a brief outline of
the options and their meanings in a comment. 
The <code>BEGIN</code> rule deals with the command-line arguments and options. It
uses a trick to get <code>getopt</code> to handle options of the form &lsquo;<samp><span class="samp">-25</span></samp>&rsquo;,
treating such an option as the option letter &lsquo;<samp><span class="samp">2</span></samp>&rsquo; with an argument of
&lsquo;<samp><span class="samp">5</span></samp>&rsquo;. If indeed two or more digits are supplied (<code>Optarg</code> looks
like a number), <code>Optarg</code> is
concatenated with the option digit and then the result is added to zero to make
it into a number.  If there is only one digit in the option, then
<code>Optarg</code> is not needed. In this case, <code>Optind</code> must be decremented so that
<code>getopt</code> processes it next time.  This code is admittedly a bit
tricky.

   <p>If no options are supplied, then the default is taken, to print both
repeated and nonrepeated lines.  The output file, if provided, is assigned
to <code>outputfile</code>.  Early on, <code>outputfile</code> is initialized to the
standard output, <samp><span class="file">/dev/stdout</span></samp>:

   <p><a name="index-g_t_0040code_007buniq_002eawk_007d-program-1792"></a>
<pre class="example">     <!-- file eg/prog/uniq.awk -->
     # uniq.awk --- do uniq in awk
     #
     # Requires getopt and join library functions
     <!-- endfile -->
     <!-- file eg/prog/uniq.awk -->
     function usage(    e)
     {
         e = "Usage: uniq [-udc [-n]] [+n] [ in [ out ]]"
         print e &gt; "/dev/stderr"
         exit 1
     }
     
     # -c    count lines. overrides -d and -u
     # -d    only repeated lines
     # -u    only non-repeated lines
     # -n    skip n fields
     # +n    skip n characters, skip fields first
     
     BEGIN   \
     {
         count = 1
         outputfile = "/dev/stdout"
         opts = "udc0:1:2:3:4:5:6:7:8:9:"
         while ((c = getopt(ARGC, ARGV, opts)) != -1) {
             if (c == "u")
                 non_repeated_only++
             else if (c == "d")
                 repeated_only++
             else if (c == "c")
                 do_count++
             else if (index("0123456789", c) != 0) {
                 # getopt requires args to options
                 # this messes us up for things like -5
                 if (Optarg ~ /^[0-9]+$/)
                     fcount = (c Optarg) + 0
                 else {
                     fcount = c + 0
                     Optind--
                 }
             } else
                 usage()
         }
     
         if (ARGV[Optind] ~ /^\+[0-9]+$/) {
             charcount = substr(ARGV[Optind], 2) + 0
             Optind++
         }
     
         for (i = 1; i &lt; Optind; i++)
             ARGV[i] = ""
     
         if (repeated_only == 0 &amp;&amp; non_repeated_only == 0)
             repeated_only = non_repeated_only = 1
     
         if (ARGC - Optind == 2) {
             outputfile = ARGV[ARGC - 1]
             ARGV[ARGC - 1] = ""
         }
     }
     <!-- endfile -->
</pre>
   <p>The following function, <code>are_equal</code>, compares the current line,
<code>$0</code>, to the
previous line, <code>last</code>.  It handles skipping fields and characters. 
If no field count and no character count are specified, <code>are_equal</code>
simply returns one or zero depending upon the result of a simple string
comparison of <code>last</code> and <code>$0</code>.  Otherwise, things get more
complicated. 
If fields have to be skipped, each line is broken into an array using
<code>split</code>
(see <a href="String-Functions.html#String-Functions">String Functions</a>);
the desired fields are then joined back into a line using <code>join</code>. 
The joined lines are stored in <code>clast</code> and <code>cline</code>. 
If no fields are skipped, <code>clast</code> and <code>cline</code> are set to
<code>last</code> and <code>$0</code>, respectively. 
Finally, if characters are skipped, <code>substr</code> is used to strip off the
leading <code>charcount</code> characters in <code>clast</code> and <code>cline</code>.  The
two strings are then compared and <code>are_equal</code> returns the result:

<pre class="example">     <!-- file eg/prog/uniq.awk -->
     function are_equal(    n, m, clast, cline, alast, aline)
     {
         if (fcount == 0 &amp;&amp; charcount == 0)
             return (last == $0)
     
         if (fcount &gt; 0) {
             n = split(last, alast)
             m = split($0, aline)
             clast = join(alast, fcount+1, n)
             cline = join(aline, fcount+1, m)
         } else {
             clast = last
             cline = $0
         }
         if (charcount) {
             clast = substr(clast, charcount + 1)
             cline = substr(cline, charcount + 1)
         }
     
         return (clast == cline)
     }
     <!-- endfile -->
</pre>
   <p>The following two rules are the body of the program.  The first one is
executed only for the very first line of data.  It sets <code>last</code> equal to
<code>$0</code>, so that subsequent lines of text have something to be compared to.

   <p>The second rule does the work. The variable <code>equal</code> is one or zero,
depending upon the results of <code>are_equal</code>'s comparison. If <samp><span class="command">uniq</span></samp>
is counting repeated lines, and the lines are equal, then it increments the <code>count</code> variable. 
Otherwise, it prints the line and resets <code>count</code>,
since the two lines are not equal.

   <p>If <samp><span class="command">uniq</span></samp> is not counting, and if the lines are equal, <code>count</code> is incremented. 
Nothing is printed, since the point is to remove duplicates. 
Otherwise, if <samp><span class="command">uniq</span></samp> is counting repeated lines and more than
one line is seen, or if <samp><span class="command">uniq</span></samp> is counting nonrepeated lines
and only one line is seen, then the line is printed, and <code>count</code>
is reset.

   <p>Finally, similar logic is used in the <code>END</code> rule to print the final
line of input data:

<pre class="example">     <!-- file eg/prog/uniq.awk -->
     NR == 1 {
         last = $0
         next
     }
     
     {
         equal = are_equal()
     
         if (do_count) {    # overrides -d and -u
             if (equal)
                 count++
             else {
                 printf("%4d %s\n", count, last) &gt; outputfile
                 last = $0
                 count = 1    # reset
             }
             next
         }
     
         if (equal)
             count++
         else {
             if ((repeated_only &amp;&amp; count &gt; 1) ||
                 (non_repeated_only &amp;&amp; count == 1))
                     print last &gt; outputfile
             last = $0
             count = 1
         }
     }
     
     END {
         if (do_count)
             printf("%4d %s\n", count, last) &gt; outputfile
         else if ((repeated_only &amp;&amp; count &gt; 1) ||
                 (non_repeated_only &amp;&amp; count == 1))
             print last &gt; outputfile
     }
     <!-- endfile -->
</pre>
   <!-- ENDOFRANGE prunt -->
<!-- ENDOFRANGE tpul -->
   </body></html>

