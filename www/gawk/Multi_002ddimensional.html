<html lang="en">
<head>
<title>Multi-dimensional - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Arrays.html#Arrays" title="Arrays">
<link rel="prev" href="Uninitialized-Subscripts.html#Uninitialized-Subscripts" title="Uninitialized Subscripts">
<link rel="next" href="Multi_002dscanning.html#Multi_002dscanning" title="Multi-scanning">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Multi-dimensional"></a>
<a name="Multi_002ddimensional"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Multi_002dscanning.html#Multi_002dscanning">Multi-scanning</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Uninitialized-Subscripts.html#Uninitialized-Subscripts">Uninitialized Subscripts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Arrays.html#Arrays">Arrays</a>
<hr>
</div>

<h3 class="section">7.9 Multidimensional Arrays</h3>

<p><a name="index-subscripts-in-arrays_002c-multidimensional-1132"></a><a name="index-arrays_002c-multidimensional-1133"></a>A multidimensional array is an array in which an element is identified
by a sequence of indices instead of a single index.  For example, a
two-dimensional array requires two indices.  The usual way (in most
languages, including <samp><span class="command">awk</span></samp>) to refer to an element of a
two-dimensional array named <code>grid</code> is with
<code>grid[</code><var>x</var><code>,</code><var>y</var><code>]</code>.

   <p><a name="index-g_t_0040code_007bSUBSEP_007d-variable_002c-multidimensional-arrays-1134"></a>Multidimensional arrays are supported in <samp><span class="command">awk</span></samp> through
concatenation of indices into one string. 
<samp><span class="command">awk</span></samp> converts the indices into strings
(see <a href="Conversion.html#Conversion">Conversion</a>) and
concatenates them together, with a separator between them.  This creates
a single string that describes the values of the separate indices.  The
combined string is used as a single index into an ordinary,
one-dimensional array.  The separator used is the value of the built-in
variable <code>SUBSEP</code>.

   <p>For example, suppose we evaluate the expression &lsquo;<samp><span class="samp">foo[5,12] = "value"</span></samp>&rsquo;
when the value of <code>SUBSEP</code> is <code>"@"</code>.  The numbers 5 and 12 are
converted to strings and
concatenated with an &lsquo;<samp><span class="samp">@</span></samp>&rsquo; between them, yielding <code>"5@12"</code>; thus,
the array element <code>foo["5@12"]</code> is set to <code>"value"</code>.

   <p>Once the element's value is stored, <samp><span class="command">awk</span></samp> has no record of whether
it was stored with a single index or a sequence of indices.  The two
expressions &lsquo;<samp><span class="samp">foo[5,12]</span></samp>&rsquo; and &lsquo;<samp><span class="samp">foo[5&nbsp;SUBSEP&nbsp;12]</span></samp>&rsquo;<!-- /@w --> are always
equivalent.

   <p>The default value of <code>SUBSEP</code> is the string <code>"\034"</code>,
which contains a nonprinting character that is unlikely to appear in an
<samp><span class="command">awk</span></samp> program or in most input data. 
The usefulness of choosing an unlikely character comes from the fact
that index values that contain a string matching <code>SUBSEP</code> can lead to
combined strings that are ambiguous.  Suppose that <code>SUBSEP</code> is
<code>"@"</code>; then &lsquo;<samp><span class="samp">foo["a@b",&nbsp;"c"]</span></samp>&rsquo;<!-- /@w --> and &lsquo;<samp><span class="samp">foo["a",&nbsp;"b@c"]</span></samp>&rsquo;<!-- /@w --> are indistinguishable because both are actually
stored as &lsquo;<samp><span class="samp">foo["a@b@c"]</span></samp>&rsquo;.

   <p>To test whether a particular index sequence exists in a
multidimensional array, use the same operator (&lsquo;<samp><span class="samp">in</span></samp>&rsquo;) that is
used for single dimensional arrays.  Write the whole sequence of indices
in parentheses, separated by commas, as the left operand:

<pre class="example">     (<var>subscript1</var>, <var>subscript2</var>, ...) in <var>array</var>
</pre>
   <p>The following example treats its input as a two-dimensional array of
fields; it rotates this array 90 degrees clockwise and prints the
result.  It assumes that all lines have the same number of
elements:

<pre class="example">     {
          if (max_nf &lt; NF)
               max_nf = NF
          max_nr = NR
          for (x = 1; x &lt;= NF; x++)
               vector[x, NR] = $x
     }
     
     END {
          for (x = 1; x &lt;= max_nf; x++) {
               for (y = max_nr; y &gt;= 1; --y)
                    printf("%s ", vector[x, y])
               printf("\n")
          }
     }
</pre>
   <p class="noindent">When given the input:

<pre class="example">     1 2 3 4 5 6
     2 3 4 5 6 1
     3 4 5 6 1 2
     4 5 6 1 2 3
</pre>
   <p class="noindent">the program produces the following output:

<pre class="example">     4 3 2 1
     5 4 3 2
     6 5 4 3
     1 6 5 4
     2 1 6 5
     3 2 1 6
</pre>
   </body></html>

