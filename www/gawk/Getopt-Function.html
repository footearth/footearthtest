<html lang="en">
<head>
<title>Getopt Function - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Library-Functions.html#Library-Functions" title="Library Functions">
<link rel="prev" href="Data-File-Management.html#Data-File-Management" title="Data File Management">
<link rel="next" href="Passwd-Functions.html#Passwd-Functions" title="Passwd Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Getopt-Function"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Passwd-Functions.html#Passwd-Functions">Passwd Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Data-File-Management.html#Data-File-Management">Data File Management</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Library-Functions.html#Library-Functions">Library Functions</a>
<hr>
</div>

<h3 class="section">12.4 Processing Command-Line Options</h3>

<!-- STARTOFRANGE libfclo -->
<p><a name="index-libraries-of-_0040command_007bawk_007d-functions_002c-command_002dline-options-1695"></a><!-- STARTOFRANGE flibclo -->
<a name="index-functions_002c-library_002c-command_002dline-options-1696"></a><!-- STARTOFRANGE clop -->
<a name="index-command_002dline-options_002c-processing-1697"></a><!-- STARTOFRANGE oclp -->
<a name="index-options_002c-command_002dline_002c-processing-1698"></a><!-- STARTOFRANGE clibf -->
<a name="index-functions_002c-library_002c-C-library-1699"></a><a name="index-arguments_002c-processing-1700"></a>Most utilities on POSIX compatible systems take options, or &ldquo;switches,&rdquo; on
the command line that can be used to change the way a program behaves. 
<samp><span class="command">awk</span></samp> is an example of such a program
(see <a href="Options.html#Options">Options</a>). 
Often, options take <dfn>arguments</dfn>; i.e., data that the program needs to
correctly obey the command-line option.  For example, <samp><span class="command">awk</span></samp>'s
<samp><span class="option">-F</span></samp> option requires a string to use as the field separator. 
The first occurrence on the command line of either <samp><span class="option">--</span></samp> or a
string that does not begin with &lsquo;<samp><span class="samp">-</span></samp>&rsquo; ends the options.

   <p><a name="index-g_t_0040code_007bgetopt_007d-function-_0028C-library_0029-1701"></a>Modern Unix systems provide a C function named <code>getopt</code> for processing
command-line arguments.  The programmer provides a string describing the
one-letter options. If an option requires an argument, it is followed in the
string with a colon.  <code>getopt</code> is also passed the
count and values of the command-line arguments and is called in a loop. 
<code>getopt</code> processes the command-line arguments for option letters. 
Each time around the loop, it returns a single character representing the
next option letter that it finds, or &lsquo;<samp><span class="samp">?</span></samp>&rsquo; if it finds an invalid option. 
When it returns &minus;1, there are no options left on the command line.

   <p>When using <code>getopt</code>, options that do not take arguments can be
grouped together.  Furthermore, options that take arguments require that the
argument is present.  The argument can immediately follow the option letter,
or it can be a separate command-line argument.

   <p>Given a hypothetical program that takes
three command-line options, <samp><span class="option">-a</span></samp>, <samp><span class="option">-b</span></samp>, and <samp><span class="option">-c</span></samp>, where
<samp><span class="option">-b</span></samp> requires an argument, all of the following are valid ways of
invoking the program:

<pre class="example">     prog -a -b foo -c data1 data2 data3
     prog -ac -bfoo -- data1 data2 data3
     prog -acbfoo data1 data2 data3
</pre>
   <p>Notice that when the argument is grouped with its option, the rest of
the argument is considered to be the option's argument. 
In this example, <samp><span class="option">-acbfoo</span></samp> indicates that all of the
<samp><span class="option">-a</span></samp>, <samp><span class="option">-b</span></samp>, and <samp><span class="option">-c</span></samp> options were supplied,
and that &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; is the argument to the <samp><span class="option">-b</span></samp> option.

   <p><code>getopt</code> provides four external variables that the programmer can use:

     <dl>
<dt><code>optind</code><dd>The index in the argument value array (<code>argv</code>) where the first
nonoption command-line argument can be found.

     <br><dt><code>optarg</code><dd>The string value of the argument to an option.

     <br><dt><code>opterr</code><dd>Usually <code>getopt</code> prints an error message when it finds an invalid
option.  Setting <code>opterr</code> to zero disables this feature.  (An
application might want to print its own error message.)

     <br><dt><code>optopt</code><dd>The letter representing the command-line option. 
<!-- While not usually documented, most versions supply this variable. -->
</dl>

   <p>The following C fragment shows how <code>getopt</code> might process command-line
arguments for <samp><span class="command">awk</span></samp>:

<pre class="example">     int
     main(int argc, char *argv[])
     {
         ...
         /* print our own message */
         opterr = 0;
         while ((c = getopt(argc, argv, "v:f:F:W:")) != -1) {
             switch (c) {
             case 'f':    /* file */
                 ...
                 break;
             case 'F':    /* field separator */
                 ...
                 break;
             case 'v':    /* variable assignment */
                 ...
                 break;
             case 'W':    /* extension */
                 ...
                 break;
             case '?':
             default:
                 usage();
                 break;
             }
         }
         ...
     }
</pre>
   <p>As a side point, <samp><span class="command">gawk</span></samp> actually uses the GNU <code>getopt_long</code>
function to process both normal and GNU-style long options
(see <a href="Options.html#Options">Options</a>).

   <p>The abstraction provided by <code>getopt</code> is very useful and is quite
handy in <samp><span class="command">awk</span></samp> programs as well.  Following is an <samp><span class="command">awk</span></samp>
version of <code>getopt</code>.  This function highlights one of the
greatest weaknesses in <samp><span class="command">awk</span></samp>, which is that it is very poor at
manipulating single characters.  Repeated calls to <code>substr</code> are
necessary for accessing individual characters
(see <a href="String-Functions.html#String-Functions">String Functions</a>).<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

   <p>The discussion that follows walks through the code a bit at a time:

   <p><a name="index-g_t_0040code_007bgetopt_007d-user_002ddefined-function-1702"></a>
<pre class="example">     <!-- file eg/lib/getopt.awk -->
     # getopt.awk --- do C library getopt(3) function in awk
     <!-- endfile -->
     <!-- file eg/lib/getopt.awk -->
     # External variables:
     #    Optind -- index in ARGV of first nonoption argument
     #    Optarg -- string value of argument to current option
     #    Opterr -- if nonzero, print our own diagnostic
     #    Optopt -- current option letter
     
     # Returns:
     #    -1     at end of options
     #    ?      for unrecognized option
     #    &lt;c&gt;    a character representing the current option
     
     # Private Data:
     #    _opti  -- index in multi-flag option, e.g., -abc
     <!-- endfile -->
</pre>
   <p>The function starts out with
a list of the global variables it uses,
what the return values are, what they mean, and any global variables that
are &ldquo;private&rdquo; to this library function.  Such documentation is essential
for any program, and particularly for library functions.

   <p>The <code>getopt</code> function first checks that it was indeed called with a string of options
(the <code>options</code> parameter).  If <code>options</code> has a zero length,
<code>getopt</code> immediately returns &minus;1:

   <p><a name="index-g_t_0040code_007bgetopt_007d-user_002ddefined-function-1703"></a>
<pre class="example">     <!-- file eg/lib/getopt.awk -->
     function getopt(argc, argv, options,    thisopt, i)
     {
         if (length(options) == 0)    # no options given
             return -1
     
         if (argv[Optind] == "--") {  # all done
             Optind++
             _opti = 0
             return -1
         } else if (argv[Optind] !~ /^-[^: \t\n\f\r\v\b]/) {
             _opti = 0
             return -1
         }
     <!-- endfile -->
</pre>
   <p>The next thing to check for is the end of the options.  A <samp><span class="option">--</span></samp>
ends the command-line options, as does any command-line argument that
does not begin with a &lsquo;<samp><span class="samp">-</span></samp>&rsquo;.  <code>Optind</code> is used to step through
the array of command-line arguments; it retains its value across calls
to <code>getopt</code>, because it is a global variable.

   <p>The regular expression that is used, <code>/^-[^:&nbsp;\t\n\f\r\v\b]/<!-- /@w --></code>, is
perhaps a bit of overkill; it checks for a &lsquo;<samp><span class="samp">-</span></samp>&rsquo; followed by anything
that is not whitespace and not a colon. 
If the current command-line argument does not match this pattern,
it is not an option, and it ends option processing:

<pre class="example">     <!-- file eg/lib/getopt.awk -->
         if (_opti == 0)
             _opti = 2
         thisopt = substr(argv[Optind], _opti, 1)
         Optopt = thisopt
         i = index(options, thisopt)
         if (i == 0) {
             if (Opterr)
                 printf("%c -- invalid option\n",
                                       thisopt) &gt; "/dev/stderr"
             if (_opti &gt;= length(argv[Optind])) {
                 Optind++
                 _opti = 0
             } else
                 _opti++
             return "?"
         }
     <!-- endfile -->
</pre>
   <p>The <code>_opti</code> variable tracks the position in the current command-line
argument (<code>argv[Optind]</code>).  If multiple options are
grouped together with one &lsquo;<samp><span class="samp">-</span></samp>&rsquo; (e.g., <samp><span class="option">-abx</span></samp>), it is necessary
to return them to the user one at a time.

   <p>If <code>_opti</code> is equal to zero, it is set to two, which is the index in
the string of the next character to look at (we skip the &lsquo;<samp><span class="samp">-</span></samp>&rsquo;, which
is at position one).  The variable <code>thisopt</code> holds the character,
obtained with <code>substr</code>.  It is saved in <code>Optopt</code> for the main
program to use.

   <p>If <code>thisopt</code> is not in the <code>options</code> string, then it is an
invalid option.  If <code>Opterr</code> is nonzero, <code>getopt</code> prints an error
message on the standard error that is similar to the message from the C
version of <code>getopt</code>.

   <p>Because the option is invalid, it is necessary to skip it and move on to the
next option character.  If <code>_opti</code> is greater than or equal to the
length of the current command-line argument, it is necessary to move on
to the next argument, so <code>Optind</code> is incremented and <code>_opti</code> is reset
to zero. Otherwise, <code>Optind</code> is left alone and <code>_opti</code> is merely
incremented.

   <p>In any case, because the option is invalid, <code>getopt</code> returns &lsquo;<samp><span class="samp">?</span></samp>&rsquo;. 
The main program can examine <code>Optopt</code> if it needs to know what the
invalid option letter actually is. Continuing on:

<pre class="example">     <!-- file eg/lib/getopt.awk -->
         if (substr(options, i + 1, 1) == ":") {
             # get option argument
             if (length(substr(argv[Optind], _opti + 1)) &gt; 0)
                 Optarg = substr(argv[Optind], _opti + 1)
             else
                 Optarg = argv[++Optind]
             _opti = 0
         } else
             Optarg = ""
     <!-- endfile -->
</pre>
   <p>If the option requires an argument, the option letter is followed by a colon
in the <code>options</code> string.  If there are remaining characters in the
current command-line argument (<code>argv[Optind]</code>), then the rest of that
string is assigned to <code>Optarg</code>.  Otherwise, the next command-line
argument is used (&lsquo;<samp><span class="samp">-xFOO</span></samp>&rsquo; versus &lsquo;<samp><span class="samp">-x&nbsp;FOO<!-- /@w --></span></samp>&rsquo;). In either case,
<code>_opti</code> is reset to zero, because there are no more characters left to
examine in the current command-line argument. Continuing:

<pre class="example">     <!-- file eg/lib/getopt.awk -->
         if (_opti == 0 || _opti &gt;= length(argv[Optind])) {
             Optind++
             _opti = 0
         } else
             _opti++
         return thisopt
     }
     <!-- endfile -->
</pre>
   <p>Finally, if <code>_opti</code> is either zero or greater than the length of the
current command-line argument, it means this element in <code>argv</code> is
through being processed, so <code>Optind</code> is incremented to point to the
next element in <code>argv</code>.  If neither condition is true, then only
<code>_opti</code> is incremented, so that the next option letter can be processed
on the next call to <code>getopt</code>.

   <p>The <code>BEGIN</code> rule initializes both <code>Opterr</code> and <code>Optind</code> to one. 
<code>Opterr</code> is set to one, since the default behavior is for <code>getopt</code>
to print a diagnostic message upon seeing an invalid option.  <code>Optind</code>
is set to one, since there's no reason to look at the program name, which is
in <code>ARGV[0]</code>:

<pre class="example">     <!-- file eg/lib/getopt.awk -->
     BEGIN {
         Opterr = 1    # default is to diagnose
         Optind = 1    # skip ARGV[0]
     
         # test program
         if (_getopt_test) {
             while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)
                 printf("c = &lt;%c&gt;, optarg = &lt;%s&gt;\n",
                                            _go_c, Optarg)
             printf("non-option arguments:\n")
             for (; Optind &lt; ARGC; Optind++)
                 printf("\tARGV[%d] = &lt;%s&gt;\n",
                                         Optind, ARGV[Optind])
         }
     }
     <!-- endfile -->
</pre>
   <p>The rest of the <code>BEGIN</code> rule is a simple test program.  Here is the
result of two sample runs of the test program:

<pre class="example">     $ awk -f getopt.awk -v _getopt_test=1 -- -a -cbARG bax -x
     -| c = &lt;a&gt;, optarg = &lt;&gt;
     -| c = &lt;c&gt;, optarg = &lt;&gt;
     -| c = &lt;b&gt;, optarg = &lt;ARG&gt;
     -| non-option arguments:
     -|         ARGV[3] = &lt;bax&gt;
     -|         ARGV[4] = &lt;-x&gt;
     
     $ awk -f getopt.awk -v _getopt_test=1 -- -a -x -- xyz abc
     -| c = &lt;a&gt;, optarg = &lt;&gt;
     error--&gt; x -- invalid option
     -| c = &lt;?&gt;, optarg = &lt;&gt;
     -| non-option arguments:
     -|         ARGV[4] = &lt;xyz&gt;
     -|         ARGV[5] = &lt;abc&gt;
</pre>
   <p>In both runs,
the first <samp><span class="option">--</span></samp> terminates the arguments to <samp><span class="command">awk</span></samp>, so that it does
not try to interpret the <samp><span class="option">-a</span></samp>, etc., as its own options.

   <blockquote>
<b>NOTE:</b> After <code>getopt</code> is through, it is the responsibility of the user level
code to
clear out all the elements of <code>ARGV</code> from 1 to <code>Optind</code>,
so that <samp><span class="command">awk</span></samp> does not try to process the command-line options
as file names. 
</blockquote>

   <p>Several of the sample programs presented in
<a href="Sample-Programs.html#Sample-Programs">Sample Programs</a>,
use <code>getopt</code> to process their arguments. 
<!-- ENDOFRANGE libfclo -->
<!-- ENDOFRANGE flibclo -->
<!-- ENDOFRANGE clop -->
<!-- ENDOFRANGE oclp -->

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> This
function was written before <samp><span class="command">gawk</span></samp> acquired the ability to
split strings into single characters using <code>""</code> as the separator. 
We have left it alone, since using <code>substr</code> is more portable.</p>

   <hr></div>

   </body></html>

