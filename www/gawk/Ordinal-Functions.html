<html lang="en">
<head>
<title>Ordinal Functions - The GNU Awk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU Awk User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="General-Functions.html#General-Functions" title="General Functions">
<link rel="prev" href="Cliff-Random-Function.html#Cliff-Random-Function" title="Cliff Random Function">
<link rel="next" href="Join-Function.html#Join-Function" title="Join Function">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.



   This is Edition 3 of `GAWK: Effective AWK Programming: A User's Guide for GNU Awk',
for the 3.1.7 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'', the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
  a. ``A GNU Manual''

  b. ``You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom.''
        -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Ordinal-Functions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Join-Function.html#Join-Function">Join Function</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Cliff-Random-Function.html#Cliff-Random-Function">Cliff Random Function</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="General-Functions.html#General-Functions">General Functions</a>
<hr>
</div>

<h4 class="subsection">12.2.6 Translating Between Characters and Numbers</h4>

<p><a name="index-libraries-of-_0040command_007bawk_007d-functions_002c-character-values-as-numbers-1656"></a><a name="index-functions_002c-library_002c-character-values-as-numbers-1657"></a><a name="index-characters_002c-values-of-as-numbers-1658"></a><a name="index-numbers_002c-as-values-of-characters-1659"></a>One commercial implementation of <samp><span class="command">awk</span></samp> supplies a built-in function,
<code>ord</code>, which takes a character and returns the numeric value for that
character in the machine's character set.  If the string passed to
<code>ord</code> has more than one character, only the first one is used.

   <p>The inverse of this function is <code>chr</code> (from the function of the same
name in Pascal), which takes a number and returns the corresponding character. 
Both functions are written very nicely in <samp><span class="command">awk</span></samp>; there is no real
reason to build them into the <samp><span class="command">awk</span></samp> interpreter:

   <p><a name="index-g_t_0040code_007bord_007d-user_002ddefined-function-1660"></a><a name="index-g_t_0040code_007bchr_007d-user_002ddefined-function-1661"></a>
<pre class="example">     <!-- file eg/lib/ord.awk -->
     # ord.awk --- do ord and chr
     
     # Global identifiers:
     #    _ord_:        numerical values indexed by characters
     #    _ord_init:    function to initialize _ord_
     <!-- endfile -->
     <!-- file eg/lib/ord.awk -->
     BEGIN    { _ord_init() }
     
     function _ord_init(    low, high, i, t)
     {
         low = sprintf("%c", 7) # BEL is ascii 7
         if (low == "\a") {    # regular ascii
             low = 0
             high = 127
         } else if (sprintf("%c", 128 + 7) == "\a") {
             # ascii, mark parity
             low = 128
             high = 255
         } else {        # ebcdic(!)
             low = 0
             high = 255
         }
     
         for (i = low; i &lt;= high; i++) {
             t = sprintf("%c", i)
             _ord_[t] = i
         }
     }
     <!-- endfile -->
</pre>
   <p><a name="index-character-sets-1662"></a><a name="index-character-encodings-1663"></a><a name="index-ASCII-1664"></a><a name="index-EBCDIC-1665"></a><a name="index-mark-parity-1666"></a>Some explanation of the numbers used by <code>chr</code> is worthwhile. 
The most prominent character set in use today is ASCII. Although an
8-bit byte can hold 256 distinct values (from 0 to 255), ASCII only
defines characters that use the values from 0 to 127.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
In the now distant past,
at least one minicomputer manufacturer
<!-- Pr1me, blech -->
used ASCII, but with mark parity, meaning that the leftmost bit in the byte
is always 1.  This means that on those systems, characters
have numeric values from 128 to 255. 
Finally, large mainframe systems use the EBCDIC character set, which
uses all 256 values. 
While there are other character sets in use on some older systems,
they are not really worth worrying about:

<pre class="example">     <!-- file eg/lib/ord.awk -->
     function ord(str,    c)
     {
         # only first character is of interest
         c = substr(str, 1, 1)
         return _ord_[c]
     }
     
     function chr(c)
     {
         # force c to be numeric by adding 0
         return sprintf("%c", c + 0)
     }
     <!-- endfile -->
     
     #### test code ####
     # BEGIN    \
     # {
     #    for (;;) {
     #        printf("enter a character: ")
     #        if (getline var &lt;= 0)
     #            break
     #        printf("ord(%s) = %d\n", var, ord(var))
     #    }
     # }
     <!-- endfile -->
</pre>
   <p>An obvious improvement to these functions is to move the code for the
<code>_ord_init<!-- /@w --></code> function into the body of the <code>BEGIN</code> rule.  It was
written this way initially for ease of development. 
There is a &ldquo;test program&rdquo; in a <code>BEGIN</code> rule, to test the
function.  It is commented out for production use.

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> ASCII
has been extended in many countries to use the values from 128 to 255
for country-specific characters.  If your  system uses these extensions,
you can simplify <code>_ord_init</code> to simply loop from 0 to 255.</p>

   <hr></div>

   </body></html>

