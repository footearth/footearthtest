
== 基础知识 ==

    * 数据类型
        * 八种基本数据类型
            * byte short int long float double char boolean
        * 一种引用数据类型 特殊
            * String
            * 值不可被改变
    * 常量和变量
        * 变量小写
        * 常量大写，单词用下划线（{{{_}}}）分割
        * final 定义常量
        * final, finally, finalize的区别
            * final是用来定义一个常数，或者是不能overload的方法，不能继承的类。
            * finally是try/catch block的。
            * finalize是gc的时候调用的。
    * 运算符
        * 算术运算符
        * 比较运算符
        * 逻辑运算符
        * 自增自减运算符
        * 赋值运算符
        * 位运算符
        * 移位运算符
        * 字符串串接
        * 三目运算符
    * package 包
        * 系统默认的工具包　
            * java.lang     常用
            * java.util     工具
            * java.awt      窗口
            * java.swing    图形界面
            * java.io       文件输入输出流
            * java.net      网络
            {{{
>> cd /d/Program\ Files/Java/jdk1.6.0_27/
>> mkdir src
>> cd src
>> unzip -x ../src.zip
>> ls
applet/  awt/  beans/  io/  lang/  math/
net/  nio/  rmi/  security/  sql/  text/  util/
            }}}
        * 表达、编译、生成和运行包
            * 包结构与目录结构一一对应
            * 包名不能与类名相同
            * 声明必须源文件开头
            * 包名应该全部小写 —— 编码风格
            * 每个源文件只有一个包的声明 {{{package ...;}}}
            {{{
/*
 *  PATH = .../java/aa/bb/cc/dd/test.java
 */

package aa.bb.cc.dd;

public class test {

    public static void main (String arg[]) {
        System.out.println("Hello Java!\n");
    }
}
            }}}
            {{{
>> cd .../java
>> ls
>> aa/
>> javac aa/bb/cc/dd/test.java
>> java aa.bb.cc.dd.test
Hello Java!
            }}}
    * import 导入
        * import 语句应位于 package 语句之后，类定义之前
        * 使用 {{{*}}} 号表示引入包下所有的类，也可以指定要引入的具体的类
        * 目前常用 {{{*}}} 引入包下所有的类
        * 一个类可以有 0～多条 import 语句
        * 包的搜寻方式
    * 权限控制 访问修饰符
|| private  || 同一个类中   ||              ||                  ||          ||
|| 无修饰符 || 同一个类中   || 同一个包中   ||                  ||          ||
|| protected|| 同一个类中   || 同一个包中   ||不同包中的之类对象||          ||
|| public   || 同一个类中   || 同一个包中   ||不同包中的之类对象|| 任何场合 ||

    * 类的定义方法
        {{{
<访问修饰符> [一般修饰符] class 类名 {

    [<属性定义>]
    [<构造方法定义>]
    [<方法定义>]
}
        }}}
    * 构造方法
        * 创建对象时初始化成员变量
        * 仅供JDK调用的回调方法
        * 构造方法必须与类同名
        * 并且没有返回类型，void也没有
        * 通常访问修饰符为public
        * 构造方法可以有参数也可以没有
        * 每个类至少有一个构造方法
        * 如果没写，Java将提供一个默认的构造方法，该构造方法没有参数，而且方法体为空
    * 析构方法 finalize
        * 通知垃圾回收
        * 一般不需要写析构方法
        * final, finally, finalize的区别
            * final是用来定义一个常数，或者是不能overload的方法，不能继承的类。
            * finally是try/catch block的。
            * finalize是gc的时候调用的。
    * 属性/成员
        * 对象所具有的静态属性
        * 访问修饰符 一般修饰符 类型 属性名称 = 初始值
    * 方法 class
        * 方法是对象所具有的动态功能
        * 访问修饰符 一般修饰符 返回值类型 方法名称 (参数列表) throws 异常列表 {方法体}
        * throws 异常列表
    * 形参、实参、按值与按引用传递
        * 所有皆为传值 意义有所不同
        * 拷贝的是值 意义为按值传递
        * 拷贝的是地址 意义为按引用传递
    * 创建对象实例 new
        * 为对象实例分配内存空间
        * 空间内存放属性
        * 初始化对象实例
    * 调用属性与方法
        * 类名{{{.}}(属性/方法)
        * this
            * 用来指向当前对象或者类实例
            * 点取成员
            * 区分同名变量
            * 作为方法名来初始化对象，调用本类其他的构造方法
            * 可用在构造函数与非静态方法中
            * static main 方法中不可用
            code 1 :
            {{{
public class test {

    int i = 0;

    test increment() {
        i++;
        return this;
    }

    void print() {
        System.out.println("i = "+i);
    }

    public static void main (String[] args) {
        test x = new test();
        x.increment().print();
        x.increment().print();
        x.increment().print();
    }
}
            }}}
            console :
            {{{
>> javac test.java
>> java test
i = 1
i = 2
i = 3
            }}}
            code 2 :
            {{{
class Person {
    public void eat (Apple apple) {
        Apple peeled = apple.getPeeled();
        System.out.println("Yummy");
    }
}

class Peeler {
    static Apple peel (Apple apple) {
        // ... remove peel
        return apple; //peeled
    }
}

class Apple {
    Apple getPeeled() {
        return Peeler.peel(this);
    }
}

public class PassingThis {
    public static void main (String[] args) {
        new Person().eat(new Apple());
    }
}
            }}}
            console :
            {{{
>> javac PassingThis.java
>> java PassingThis
Yummy
            }}}
   * 包装类
        * JDK中针对各种基本数据类型分别定义相应的引用类型 Wrapper Classes
|| * 基本数据类型 * || * 对应的包装类 * ||
||boolean           ||Boolean           ||
||byte              ||Byte              ||
||short             ||Short             ||
||int               ||Integer           ||
||long              ||Long              ||
||char              ||Character         ||
||float             ||Float             ||
||double            ||Double            ||

        * 自动包装与解包
            code :
            {{{
public class test {

    public static void main (String args[]) {
        Integer a1 = 5; // 自动包装
        int a2 = new Integer(5); //自动解包
        System.out.println("a1 = "+a1+", a2 = "+a2);
    }
}
            }}}
            console :
            {{{
>> javac .../Test.java
>> java Test
a1 = 5, a2 = 5
            }}}
        * 类型转换
            * 强制类型转换

    * [http://www.cnblogs.com/clongge/archive/2008/07/09/1239076.html 面向对象三个基本特征]
        * 封装
        * 继承
            * extends
            * public class A extends B{}
                * 表示A类继承B类，A类自动具有B类允许其能访问的所有变量和属性
                * 尽管一个子类从父类继承所有的方法和变量，但它不继承构造方法
                    * 一个类能得到构造方法，只有两个方法
                        # 自己写构造方法
                        # 系统默认设置的构造方法
                * 初始化一个类必先初始化属性
                * 初始化子类必先初始化父类
                * 运行顺序
                    # 父类 属性
                    # 父类 构造方法
                    # 子类 属性
                    # 子类 构造方法
                * suer 用来引用该类的父类的成员变量或方法
                    * 父类方法被调用，就好象该方法是本类的行为一样，该方法不必在父类中定义
                    * 也可以从某些祖先类中继承，也就是说可以从父类的父类中去获取，具有追溯性
                    * 功能
                        * 点取父类中被子类隐藏了的数据成员
                        * 点取已经覆盖了的属性与方法
                        * 作为方法名表示父类构造方法
                            * this/super 一定要写在子类构造方法的第一行
                            * 如果没有使用super调用父类构造方法
                            * 默认的在子类构造方法中加入 super()
                            * 如果父类中没有无参的构造方法会产生一个编译错误
                * Java 类的继承只能是单继承的
        * 多态
    * 重载
        * 多个同类型参数的方法
        * 5.0以前
            {{{
int sum (Integer[] numbers) {...}
sum (new Integer[] {12,13,20});
            }}}
        * 5.0以后
            {{{
int sum (Integer ... numbers) {...}
sum (12,13,20);
            }}}
    * 泛型

== CODE ==

{{{
/*
 * FileName : .../test.java
 * 输出图形
 *  *
 *  * *
 *  * * *
 *  * * * *
 *  *
 *  * *
 *  * * *
 *  * * * *
 */
public class test {

    public static void main (String arg[]) {

        for (int k=0; k<2; k++) {
            for (int i=0; i<4; i++) {
                for (int j=0; j<i+1; j++) {
                    // System.out.print("k="+k+", i="+i+", j="+j);
                    System.out.print(" * ");
                }
                System.out.print("\n");
            }
        }
    }
}
}}}

{{{
/*
 * 找1000以内的质素
 */
public class test {

    public static void main (String[] args) {

    System.out.println("2");

        for (int i=3; i<=1000; i++) {

            boolean IsPrime = true;

            for (int j=2; j<=Math.sqrt(i) ; j++) {

                if (i % j == 0) {
                    IsPrime = false;
                    break;
                }
            }

            if (IsPrime) System.out.println(i);
        }
    }
}
}}}

